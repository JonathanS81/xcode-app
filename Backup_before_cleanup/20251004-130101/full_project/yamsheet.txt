

================================================================================
FILE: YamSheet/ContentView.swift
================================================================================

import SwiftUI
import SwiftData

struct ContentView: View {
    var body: some View {
        TabView {
            GamesListView()
                .tabItem { Label(UIStrings.Common.games, systemImage: "list.bullet.rectangle") }
            PlayersListView()
                .tabItem { Label(UIStrings.Common.players, systemImage: "person.3") }
            NotationsListView()
                .tabItem { Label(UIStrings.Common.notations, systemImage: "text.badge.star") }
            StatisticsTab()
                .tabItem {
                    Image(systemName: "chart.bar")
                    Text("Stats")
                }
            SettingsView()
                .tabItem { Label(UIStrings.Common.settings, systemImage: "gear") }
            
        }
    }
}

#Preview {
    ContentView()
  .modelContainer(for: [AppSettings.self, Player.self, Game.self, Scorecard.self], inMemory: true)
}



================================================================================
FILE: YamSheet/DebugViews.swift
================================================================================

//
//  DebugViews.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 08/09/2025.
//

import SwiftUI

struct LottieSmokeTest: View {
    var body: some View {
        VStack(spacing: 12) {
            Text("Smoke Test Lottie").font(.headline)
            LottieRandomCelebrationView(
                names: ["Confetti", "Confetti2", "Confetti3", "Fireworks"],
                loopOnce: true, speed: 1.0, subdirectory: "Resources" // ← BLEU
            )
            .frame(height: 200)
            .background(Color.black.opacity(0.05))
            .clipShape(RoundedRectangle(cornerRadius: 12))
        }
        .padding()
    }
}



================================================================================
FILE: YamSheet/Logic/TurnRules.swift
================================================================================

//
//  TurnRules.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/09/2025.
//
import Foundation

/// Compte le nombre de cases REMPLIES (requises + optionnelles) pour un joueur.
/// valueForKey doit retourner `nil` si la cellule est vide, sinon la valeur (Int).
func fillableCount(game: Game, playerID: UUID, valueForKey: (UUID, String) -> Int?) -> Int {
    game.allFillableKeys.reduce(0) { acc, key in
        acc + (valueForKey(playerID, key) == nil ? 0 : 1)
    }
}

/// Nombre de cases REQUISES par joueur (figées selon les options).
func requiredCellsPerPlayer(game: Game) -> Int {
    game.requiredNotationKeys.count
}

/// Test de fin de partie (toutes les REQUISES remplies pour tous).
func isGameCompleted(game: Game, valueForKey: (UUID, String) -> Int?) -> Bool {
    game.turnOrder.allSatisfy { pid in
        game.requiredNotationKeys.allSatisfy { key in valueForKey(pid, key) != nil }
    }
}




================================================================================
FILE: YamSheet/Models/ColorCodable.swift
================================================================================

//
//  ColorCodable.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/09/2025.
//

import SwiftUI
import UIKit   // ✅ nécessaire pour UIColor

/// Helper pour rendre Color Codable (RGBA)
struct ColorCodable: Codable {
    let red: CGFloat
    let green: CGFloat
    let blue: CGFloat
    let alpha: CGFloat

    init(_ color: Color) {
        let uiColor = UIColor(color)
        var r: CGFloat = 0
        var g: CGFloat = 0
        var b: CGFloat = 0
        var a: CGFloat = 0
        uiColor.getRed(&r, green: &g, blue: &b, alpha: &a)
        self.red = r
        self.green = g
        self.blue = b
        self.alpha = a
    }

    var color: Color {
        Color(
            red: Double(red),
            green: Double(green),
            blue: Double(blue),
            opacity: Double(alpha)
        )
    }
}



================================================================================
FILE: YamSheet/Models/Enums.swift
================================================================================

import Foundation

enum GameStatus: String, Codable, CaseIterable, Identifiable {
    case inProgress, paused, completed
    var id: String { rawValue }
}




================================================================================
FILE: YamSheet/Models/Game+TurnEngine.swift
================================================================================

//
//  Game+TurnEngine.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/09/2025.
//

import Foundation

extension Game {
    // Joueur actif (uniquement si la partie est en cours)
    var activePlayerID: UUID? {
        guard statusOrDefault == .inProgress,
              !turnOrder.isEmpty,
              currentTurnIndex < turnOrder.count else { return nil }
        return turnOrder[currentTurnIndex]
    }

    func isActive(playerID: UUID) -> Bool {
        activePlayerID == playerID
    }

    // Configuration de l'ordre (aléatoire ou manuel)
    func setTurnOrder(_ ids: [UUID]) {
        // Filtre de sécurité : si participantIDs est défini, on ne garde que ces IDs-là
        let valid: [UUID]
        if !participantIDs.isEmpty {
            let allowed = Set(participantIDs)
            valid = ids.filter { allowed.contains($0) }
        } else {
            valid = ids
        }

        turnOrder = valid
        currentTurnIndex = 0
        lastFilledCountByPlayer = [:]
        statusOrDefault = .inProgress
        startedAt = Date()
        endedAt = nil
    }

    // Figer les notations (13…15 requises selon options, bonus en optionnel)
    func configureNotations(required: [String], optional: [String]) {
        requiredNotationKeys = required
        optionalNotationKeys = optional
    }

    // Toutes les cases saisissables (pour la validation "1 case")
    var allFillableKeys: [String] { requiredNotationKeys + optionalNotationKeys }

    // Snapshot du début de tour
    func beginTurnSnapshot(for playerID: UUID, fillableCount: Int) {
        if lastFilledCountByPlayer[playerID] == nil {
            lastFilledCountByPlayer[playerID] = fillableCount
        }
    }

    // Valider "exactement 1 case" saisie durant le tour
    func canEndTurn(for playerID: UUID, fillableCount: Int) -> Bool {
        let start = lastFilledCountByPlayer[playerID] ?? fillableCount
        return (fillableCount - start) == 1
    }

    // Commit de fin de tour
    func endTurnCommit(for playerID: UUID, fillableCount: Int) {
        lastFilledCountByPlayer[playerID] = fillableCount
    }

    // Joueur suivant
    func advanceToNextPlayer() {
        guard !turnOrder.isEmpty else { return }
        currentTurnIndex = (currentTurnIndex + 1) % turnOrder.count
    }

    // Fin de partie: toutes les REQUISES sont remplies
    func completeIfFinished(requiredCellsPerPlayer: Int,
                            filledCount: (UUID) -> Int) -> Bool {
        let allDone = turnOrder.allSatisfy { pid in
            filledCount(pid) >= requiredCellsPerPlayer
        }
        if allDone {
            statusOrDefault = .completed
            endedAt = Date()
        }
        return allDone
    }
}

// MARK: - Jump direct vers un joueur
extension Game {
    /// Rend actif ce joueur immédiatement (ne change pas l'ordre).
    func jumpTo(playerID pid: UUID) {
        guard let idx = turnOrder.firstIndex(of: pid) else { return }
        self.currentTurnIndex = idx   // ← adapte le nom si ta propriété s'appelle autrement
    }
}




================================================================================
FILE: YamSheet/Models/Game.swift
================================================================================

import Foundation
import SwiftData

@Model
final class Game: Identifiable {
    var id: UUID
    
    var participantIDs: [UUID] = []

    
    // MARK: - Turn Engine (stored properties)
    
    
    
    // Paramètres figés au moment de la création (compat existante)
    var upperBonusThreshold: Int
    var upperBonusValue: Int
    var enableSmallStraight: Bool
    var smallStraightScore: Int
    
    // Nom lisible de la partie
    var name: String = ""

    //Prime Extra Yams
    var enableExtraYamsBonus: Bool = true

    // Options de figures (par partie)
    var enableChance: Bool = true
    // (tu as déjà enableSmallStraight d’après GameDetailView)
    
    // Notation figée (snapshot JSON)
    var notationData: Data
    
    // State
    var createdAt: Date
    var comment: String
    var columns: Int
    var statusRaw: String
    
    // Relationship
    @Relationship(deleteRule: .cascade) var scorecards: [Scorecard] = []
    
    // MARK: - Turn Engine (stored properties)

    var status: GameStatus? = nil

    /// Toujours utiliser ce getter/setter pour lire/écrire le statut
    var statusOrDefault: GameStatus {
        get { status ?? .inProgress }
        set { status = newValue }
    }

    /// Ordre de passage des joueurs (IDs stables)
    var turnOrder: [UUID] = [] as [UUID]             // annotation explicite

    /// Index du joueur actif dans `turnOrder`
    var currentTurnIndex: Int = 0

    // --- Snapshot "1 case par tour": stockage en Data + propriété calculée ---
    @Attribute(.externalStorage)
    var lastFilledCountSnapshotData: Data? = nil

    var lastFilledCountByPlayer: [UUID: Int] {
        get {
            guard let data = lastFilledCountSnapshotData else { return [:] }
            // On décode un dictionnaire [UUID: Int]; fallback sur [:] si échec
            return (try? JSONDecoder().decode([UUID: Int].self, from: data)) ?? [:]
        }
        set {
            lastFilledCountSnapshotData = try? JSONEncoder().encode(newValue)
        }
    }

    /// Cases obligatoires (figées selon options)
    var requiredNotationKeys: [String] = [] as [String]

    /// Cases optionnelles (ex: prime Yams supplémentaire)
    var optionalNotationKeys: [String] = [] as [String]

    /// Dates
    var startedAt: Date? = nil
    var endedAt: Date? = nil

    
    
    // Helpers JSON
    // Helpers JSON (sans force-unwrap)
    private static let encoder = JSONEncoder()
    private static let decoder = JSONDecoder()

    // Fallback pour les anciennes parties (notationData vide / illisible)
    private func safeDefaultNotation() -> NotationSnapshot {
        NotationSnapshot(
            name: "Par défaut",
            tooltipUpper: "Atteindre \(upperBonusThreshold) en haut donne +\(upperBonusValue).",
            tooltipMiddle: "Multiplier : (Max − Min) × nombre d’As.",
            tooltipBottom: "Figures calculées selon la saisie (somme/prime).",
            upperBonusThreshold: upperBonusThreshold,
            upperBonusValue: upperBonusValue,
            middleMode: .multiplier,
            middleBonusSumThreshold: 50,
            middleBonusValue: 30,
            // Règles raisonnables par défaut
            ruleBrelan: FigureRule(mode: .raw),
            ruleChance: FigureRule(mode: .raw),
            ruleFull: FigureRule(mode: .rawPlusFixed, fixedValue: 30),
            ruleSuite: FigureRule(mode: .fixed, fixedValue: 0), // non utilisé avec la logique SuiteBig
            rulePetiteSuite: FigureRule(mode: .fixed, fixedValue: enableSmallStraight ? smallStraightScore : 0),
            ruleCarre: FigureRule(mode: .rawPlusFixed, fixedValue: 40),
            ruleYams: FigureRule(mode: .rawPlusFixed, fixedValue: 50),
            // Grande suite : 1–5 et 2–6 distinctes
            suiteBigMode: .splitFixed,
            suiteBigFixed: 0,          // ignoré en split
            suiteBigFixed1to5: 15,
            suiteBigFixed2to6: 20,
            // Bonus Yams sup désactivé par défaut
            extraYamsBonusEnabled: false,
            extraYamsBonusValue: 0
        )
    }

    // Notation figée pour la partie (avec upgrade transparent)
    var notation: NotationSnapshot {
        if !notationData.isEmpty,
           let snap = try? Game.decoder.decode(NotationSnapshot.self, from: notationData) {
            return snap
        } else {
            let fallback = safeDefaultNotation()
            // Upgrade : on persiste un snapshot par défaut,
            // il sera sauvegardé lors d’un prochain save() du ModelContext.
            notationData = (try? Game.encoder.encode(fallback)) ?? Data()
            return fallback
        }
    }

    
    init(settings: AppSettings, notation: NotationSnapshot, columns: Int = 1, comment: String = "") {
        self.id = UUID()
        self.upperBonusThreshold = settings.upperBonusThreshold
        self.upperBonusValue = settings.upperBonusValue
        self.enableSmallStraight = settings.enableSmallStraight
        self.smallStraightScore = settings.smallStraightScore
        self.notationData = (try? JSONEncoder().encode(notation)) ?? Data()
        self.createdAt = Date()
        self.comment = comment
        self.columns = columns
        self.statusRaw = GameStatus.inProgress.rawValue
    }
}

import Foundation

extension Game {
    /// Applique les options de création et fige la notation pour la partie
    func applyCreationOptions(
        name: String,
        enableChance: Bool,
        enableSmallStraight: Bool,
        notation: Notation
    ) {
        self.name = name
        self.enableChance = enableChance
        self.enableSmallStraight = enableSmallStraight

        // On fige la notation (snapshot) dans la partie
        let snap = notation.snapshot()
        if let data = try? JSONEncoder().encode(snap) {
            self.notationData = data
        } else {
            self.notationData = Data()
        }
    }
}







================================================================================
FILE: YamSheet/Models/Notation.swift
================================================================================

//
//  Notation.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/08/2025.
//

import Foundation
import SwiftData

// Règle pour la section du milieu
enum MiddleRuleMode: String, Codable, CaseIterable, Identifiable {
    case multiplier      // (Max - Min) * (#As)
    case bonusGate       // si Max > Min ET Max+Min >= seuil => +bonus
    var id: String { rawValue }
}

// Mode de calcul pour les figures de la section basse
enum BottomRuleMode: String, Codable, CaseIterable, Identifiable {
    case raw            // valeur saisie telle quelle
    case fixed          // valeur fixe si > 0 (marquée), 0 si barrée
    case rawPlusFixed   // valeur saisie + prime fixe
    case rawTimes       // valeur saisie * multiplicateur
    var id: String { rawValue }
}

struct FigureRule: Codable, Hashable {
    var mode: BottomRuleMode
    var fixedValue: Int     // utilisé pour fixed (valeur), ou pour rawPlusFixed (prime)
    var multiplier: Int     // utilisé pour rawTimes (>=1)
    var tooltip: String?
    
    init(mode: BottomRuleMode = .raw, fixedValue: Int = 0, multiplier: Int = 1, tooltip: String? = nil) {
        self.mode = mode
        self.fixedValue = fixedValue
        self.multiplier = max(1, multiplier)
        self.tooltip = tooltip
    }
}
enum SuiteBigMode: String, Codable, CaseIterable, Identifiable {
    case singleFixed   // une valeur fixe pour n’importe quelle grande suite
    case splitFixed    // valeur fixe pour 1–5 et valeur fixe pour 2–6
    var id: String { rawValue }
}

// Les règles compactées (snapshot) qu’on figera sur Game
struct NotationSnapshot: Codable {
    // Nom + tooltips globaux
    var name: String
    var tooltipUpper: String?
    var tooltipMiddle: String?
    var tooltipBottom: String?
    
    // Section haute
    var upperBonusThreshold: Int
    var upperBonusValue: Int
    
    // Section milieu
    var middleMode: MiddleRuleMode
    var middleBonusSumThreshold: Int  // utilisé seulement si .bonusGate
    var middleBonusValue: Int         // utilisé seulement si .bonusGate
    
    // Section basse : règles par figure
    var ruleBrelan: FigureRule
    var ruleChance: FigureRule
    var ruleFull: FigureRule
    var ruleSuite: FigureRule
    var rulePetiteSuite: FigureRule
    var ruleCarre: FigureRule
    var ruleYams: FigureRule
    
    // ...
    var suiteBigMode: SuiteBigMode
    var suiteBigFixed: Int
    var suiteBigFixed1to5: Int
    var suiteBigFixed2to6: Int
    // ...
    
    // Bonus Yams supplémentaire (optionnel)
    var extraYamsBonusEnabled: Bool
    var extraYamsBonusValue: Int
}

@Model
final class Notation {

    // métadonnées
    var name: String = ""
    var tooltipUpper: String? = nil
    var tooltipMiddle: String? = nil
    var tooltipBottom: String? = nil
    
    // section haute
    var upperBonusThreshold: Int = 63
    var upperBonusValue: Int = 35
    
    // section milieu
    var middleModeRaw: String = MiddleRuleMode.multiplier.rawValue   // MiddleRuleMode
    var middleBonusSumThreshold: Int = 50
    var middleBonusValue: Int = 30
    
    // section basse : règles encodées en JSON
    var ruleBrelanData: Data = Data()
    var ruleChanceData: Data = Data()
    var ruleFullData: Data = Data()
    var ruleSuiteData: Data = Data()
    var rulePetiteSuiteData: Data = Data()
    var ruleCarreData: Data = Data()
    var ruleYamsData: Data = Data()

    // Spécifique à la grande suite (5 dés)
    var suiteBigModeRaw: String = SuiteBigMode.singleFixed.rawValue
    var suiteBigFixed: Int = 15           // utilisé si .singleFixed
    var suiteBigFixed1to5: Int = 15       // utilisé si .splitFixed (1–5)
    var suiteBigFixed2to6: Int = 20       // utilisé si .splitFixed (2–6)

    var suiteBigMode: SuiteBigMode {
        get { SuiteBigMode(rawValue: suiteBigModeRaw) ?? .singleFixed }
        set { suiteBigModeRaw = newValue.rawValue }
    }
    
    // Bonus Yams en plus
    var extraYamsBonusEnabled: Bool = false
    var extraYamsBonusValue: Int = 0
    
    // Helpers d’encodage (statiques pour pouvoir être appelés dans init AVANT que self soit complet)
    private static let encoder = JSONEncoder()
    private static let decoder = JSONDecoder()
    private static func encRule(_ v: FigureRule) -> Data { (try? encoder.encode(v)) ?? Data() }
    private static func decRule(_ d: Data) -> FigureRule { (try? decoder.decode(FigureRule.self, from: d)) ?? FigureRule() }

    
    // Computed
    var middleMode: MiddleRuleMode {
        get { MiddleRuleMode(rawValue: middleModeRaw) ?? .multiplier }
        set { middleModeRaw = newValue.rawValue }
    }
    
    var ruleBrelan: FigureRule {
        get { Self.decRule(ruleBrelanData) }
        set { ruleBrelanData = Self.encRule(newValue) }
    }
    var ruleChance: FigureRule {
        get { Self.decRule(ruleChanceData) }
        set { ruleChanceData = Self.encRule(newValue) }
    }
    var ruleFull: FigureRule {
        get { Self.decRule(ruleFullData) }
        set { ruleFullData = Self.encRule(newValue) }
    }
    var ruleSuite: FigureRule {
        get { Self.decRule(ruleSuiteData) }
        set { ruleSuiteData = Self.encRule(newValue) }
    }
    var rulePetiteSuite: FigureRule {
        get { Self.decRule(rulePetiteSuiteData) }
        set { rulePetiteSuiteData = Self.encRule(newValue) }
    }
    var ruleCarre: FigureRule {
        get { Self.decRule(ruleCarreData) }
        set { ruleCarreData = Self.encRule(newValue) }
    }
    var ruleYams: FigureRule {
        get { Self.decRule(ruleYamsData) }
        set { ruleYamsData = Self.encRule(newValue) }
    }

    
    init(
        name: String,
        tooltipUpper: String? = nil,
        tooltipMiddle: String? = nil,
        tooltipBottom: String? = nil,
        upperBonusThreshold: Int = 63,
        upperBonusValue: Int = 35,
        middleMode: MiddleRuleMode = .multiplier,
        middleBonusSumThreshold: Int = 50,
        middleBonusValue: Int = 30,
        ruleBrelan: FigureRule = FigureRule(),
        ruleChance: FigureRule = FigureRule(),
        ruleFull: FigureRule = FigureRule(mode: .rawPlusFixed, fixedValue: 30),
        ruleSuite: FigureRule = FigureRule(mode: .fixed, fixedValue: 15),
        rulePetiteSuite: FigureRule = FigureRule(mode: .fixed, fixedValue: 10),
        ruleCarre: FigureRule = FigureRule(mode: .rawPlusFixed, fixedValue: 40),
        ruleYams: FigureRule = FigureRule(mode: .rawPlusFixed, fixedValue: 50),
        extraYamsBonusEnabled: Bool = false,
        extraYamsBonusValue: Int = 0
    ) {
        self.name = name
        self.tooltipUpper = tooltipUpper
        self.tooltipMiddle = tooltipMiddle
        self.tooltipBottom = tooltipBottom
        self.upperBonusThreshold = upperBonusThreshold
        self.upperBonusValue = upperBonusValue
        self.middleModeRaw = middleMode.rawValue
        self.middleBonusSumThreshold = middleBonusSumThreshold
        self.middleBonusValue = middleBonusValue
        self.ruleBrelanData = Self.encRule(ruleBrelan)
        self.ruleChanceData = Self.encRule(ruleChance)
        self.ruleFullData   = Self.encRule(ruleFull)
        self.ruleSuiteData  = Self.encRule(ruleSuite)
        self.rulePetiteSuiteData = Self.encRule(rulePetiteSuite)
        self.ruleCarreData  = Self.encRule(ruleCarre)
        self.ruleYamsData   = Self.encRule(ruleYams)
        self.suiteBigModeRaw = SuiteBigMode.singleFixed.rawValue
        self.suiteBigFixed = 15
        self.suiteBigFixed1to5 = 15
        self.suiteBigFixed2to6 = 20
        
        self.extraYamsBonusEnabled = extraYamsBonusEnabled
        self.extraYamsBonusValue = extraYamsBonusValue
    }
    

    
    
    // Snapshot pour figer dans Game
    func snapshot() -> NotationSnapshot {
        NotationSnapshot(
            name: name,
            tooltipUpper: tooltipUpper,
            tooltipMiddle: tooltipMiddle,
            tooltipBottom: tooltipBottom,
            upperBonusThreshold: upperBonusThreshold,
            upperBonusValue: upperBonusValue,
            middleMode: middleMode,
            middleBonusSumThreshold: middleBonusSumThreshold,
            middleBonusValue: middleBonusValue,
            ruleBrelan: ruleBrelan,
            ruleChance: ruleChance,
            ruleFull: ruleFull,
            ruleSuite: ruleSuite,
            rulePetiteSuite: rulePetiteSuite,
            ruleCarre: ruleCarre,
            ruleYams: ruleYams,
            // ← important : les champs SuiteBig APRÈS ruleYams
            suiteBigMode: suiteBigMode,
            suiteBigFixed: suiteBigFixed,
            suiteBigFixed1to5: suiteBigFixed1to5,
            suiteBigFixed2to6: suiteBigFixed2to6,
            // puis les bonus Yams
            extraYamsBonusEnabled: extraYamsBonusEnabled,
            extraYamsBonusValue: extraYamsBonusValue
        )
    }

}





================================================================================
FILE: YamSheet/Models/Player.swift
================================================================================

//
//  Player.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/08/2025.
//

import SwiftUI
import SwiftData

@Model
final class Player {
    // Identité
    @Attribute(.unique) var id: UUID
    var name: String
    var nickname: String

    // Champs facultatifs
    var email: String?
    var favoriteEmoji: String?

    // Couleur persistée (RGBA codée en Data)
    var colorData: Data

    // Avatar (stocké hors du fichier principal pour éviter de gonfler la DB)
    @Attribute(.externalStorage) var avatarImageData: Data?

    // Statut invité
    var isGuest: Bool

    // MARK: - Init

    init(id: UUID = UUID(),
         name: String,
         nickname: String,
         email: String? = nil,
         favoriteEmoji: String? = nil,
         color: Color = .blue,
         avatarImageData: Data? = nil,
         isGuest: Bool = false) {

        self.id = id
        self.name = name
        self.nickname = nickname
        self.email = email
        self.favoriteEmoji = favoriteEmoji
        self.colorData = Player.encode(color)     // encodage RGBA
        self.avatarImageData = avatarImageData
        self.isGuest = isGuest
    }

    // MARK: - Couleur (computed)

    var color: Color {
        get {
            (try? JSONDecoder().decode(ColorCodable.self, from: colorData))?.color ?? .blue
        }
        set {
            colorData = Player.encode(newValue)
        }
    }

    // MARK: - Helpers

    private static func encode(_ color: Color) -> Data {
        (try? JSONEncoder().encode(ColorCodable(color))) ?? Data()
    }
}

// MARK: - UI Helpers (optionnel)

extension Player {
    /// Initiales pour un avatar monogramme (ex. “JS”)
    var initials: String {
        let parts = name.split(separator: " ")
        let first = parts.first?.first.map { String($0) } ?? ""
        let last = parts.dropFirst().first?.first.map { String($0) } ?? ""
        let nickInitial = nickname.first.map { String($0) } ?? ""
        // Priorité : initiales nom/prénom sinon initiale du surnom
        let composed = (first + last)
        return composed.isEmpty ? nickInitial : composed
    }

    /// Image d’avatar si disponible
    var avatarImage: UIImage? {
        guard let data = avatarImageData else { return nil }
        return UIImage(data: data)
    }
}



================================================================================
FILE: YamSheet/Models/Scorecard.swift
================================================================================

import Foundation
import SwiftData

/// Helper to encode/decode arrays & dicts as Data JSON
fileprivate func encodeJSON<T: Encodable>(_ value: T) -> Data {
    (try? JSONEncoder().encode(value)) ?? Data()
}
fileprivate func decodeJSON<T: Decodable>(_ type: T.Type, from data: Data) -> T {
    (try? JSONDecoder().decode(type, from: data)) ?? (T.self == [Int].self ? [] as! T : (T.self == [String: Bool].self ? [:] as! T : T.self as! T))
}

@Model
final class Scorecard: Identifiable {
    var id: UUID
    var playerID: UUID
    var columns: Int
    var extraYamsAwarded: [Bool] = []

    @Relationship(deleteRule: .nullify, inverse: \Game.scorecards) var game: Game?

    // Stored as Data (JSON)
    var onesData: Data
    var twosData: Data
    var threesData: Data
    var foursData: Data
    var fivesData: Data
    var sixesData: Data

    var maxValsData: Data
    var minValsData: Data

    var brelanData: Data
    var chanceData: Data
    var fullData: Data
    var carreData: Data
    var yamsData: Data
   
    var suiteData: Data            // grande suite (1–5 ou 2–6) : 0 / 15 / 20
    var petiteSuiteData: Data      // petite suite (si activée) : 0 / score paramétré

    var locksData: Data

    init(playerID: UUID, columns: Int) {
        self.id = UUID()
        self.playerID = playerID
        self.columns = columns

        func initArray() -> Data { encodeJSON(Array(repeating: -1, count: columns)) }
        self.onesData = initArray()
        self.twosData = initArray()
        self.threesData = initArray()
        self.foursData = initArray()
        self.fivesData = initArray()
        self.sixesData = initArray()

        self.maxValsData = initArray()
        self.minValsData = initArray()

        self.brelanData = initArray()
        self.chanceData = initArray()
        self.fullData = initArray()
        self.carreData = initArray()
        self.yamsData = initArray()
        
        self.suiteData = initArray()
        self.petiteSuiteData = initArray()
        self.extraYamsAwarded = Array(repeating: false, count: columns)

        self.locksData = encodeJSON([String: Bool]())
    }

    // Computed properties
    var ones: [Int] {
        get { decodeJSON([Int].self, from: onesData) }
        set { onesData = encodeJSON(newValue) }
    }
    var twos: [Int] {
        get { decodeJSON([Int].self, from: twosData) }
        set { twosData = encodeJSON(newValue) }
    }
    var threes: [Int] {
        get { decodeJSON([Int].self, from: threesData) }
        set { threesData = encodeJSON(newValue) }
    }
    var fours: [Int] {
        get { decodeJSON([Int].self, from: foursData) }
        set { foursData = encodeJSON(newValue) }
    }
    var fives: [Int] {
        get { decodeJSON([Int].self, from: fivesData) }
        set { fivesData = encodeJSON(newValue) }
    }
    var sixes: [Int] {
        get { decodeJSON([Int].self, from: sixesData) }
        set { sixesData = encodeJSON(newValue) }
    }

    var maxVals: [Int] {
        get { decodeJSON([Int].self, from: maxValsData) }
        set { maxValsData = encodeJSON(newValue) }
    }
    var minVals: [Int] {
        get { decodeJSON([Int].self, from: minValsData) }
        set { minValsData = encodeJSON(newValue) }
    }

    var brelan: [Int] {
        get { decodeJSON([Int].self, from: brelanData) }
        set { brelanData = encodeJSON(newValue) }
    }
    var chance: [Int] {
        get { decodeJSON([Int].self, from: chanceData) }
        set { chanceData = encodeJSON(newValue) }
    }
    var full: [Int] {
        get { decodeJSON([Int].self, from: fullData) }
        set { fullData = encodeJSON(newValue) }
    }
    var carre: [Int] {
        get { decodeJSON([Int].self, from: carreData) }
        set { carreData = encodeJSON(newValue) }
    }
    var yams: [Int] {
        get { decodeJSON([Int].self, from: yamsData) }
        set { yamsData = encodeJSON(newValue) }
    }
    
    var suite: [Int] {
            get { decodeJSON([Int].self, from: suiteData) }
            set { suiteData = encodeJSON(newValue) }
        }
    
    var petiteSuite: [Int] {
            get { decodeJSON([Int].self, from: petiteSuiteData) }
            set { petiteSuiteData = encodeJSON(newValue) }
        }

    var locks: [String: Bool] {
        get { decodeJSON([String: Bool].self, from: locksData) }
        set { locksData = encodeJSON(newValue) }
    }

    // Helpers
    func isLocked(col: Int, key: String) -> Bool {
        locks["\(col).\(key)"] ?? false
    }
    func setLocked(_ value: Bool, col: Int, key: String) {
        var l = locks
        l["\(col).\(key)"] = value
        locks = l
    }
}



================================================================================
FILE: YamSheet/Models/Settings.swift
================================================================================

//
//  Game+TurnEngine.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/09/2025.
//

import Foundation
import SwiftData

@Model
final class AppSettings {
    var upperBonusThreshold: Int
    var upperBonusValue: Int
    var enableSmallStraight: Bool
    var smallStraightScore: Int
    var darkMode: Bool
    
    init(
        upperBonusThreshold: Int = 63,
        upperBonusValue: Int = 35,
        enableSmallStraight: Bool = true,
        smallStraightScore: Int = 10,
        darkMode: Bool = false
    ) {
        self.upperBonusThreshold = upperBonusThreshold
        self.upperBonusValue = upperBonusValue
        self.enableSmallStraight = enableSmallStraight
        self.smallStraightScore = smallStraightScore
        self.darkMode = darkMode
    }
}





================================================================================
FILE: YamSheet/Models/StatsEngine.swift
================================================================================

//
//  Game+TurnEngine.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/09/2025.
//


import Foundation

enum FigureKind {
    case brelan, chance, full, suiteBig, petiteSuite, carre, yams
}

struct StatsEngine {
    //helper
    static func extraYamsBonusAmount(sc: Scorecard, game: Game, col: Int) -> Int {
        guard game.enableExtraYamsBonus,                        // partie
              game.notation.extraYamsBonusValue > 0,            // notation (0 = off)
              sc.extraYamsAwarded.indices.contains(col),
              sc.extraYamsAwarded[col] else {
            return 0
        }
        return game.notation.extraYamsBonusValue
    }

    // -1 => non rempli ; 0 => barré ; sinon valeur
    static func norm(_ v: Int) -> Int { max(0, v) }

    // MARK: - Upper
    static func upperTotal(sc: Scorecard, game: Game, col: Int) -> Int {
        let u = [
            sc.ones[col], sc.twos[col], sc.threes[col],
            sc.fours[col], sc.fives[col], sc.sixes[col]
        ].map(norm).reduce(0, +)
        let bonus = (u >= game.notation.upperBonusThreshold) ? game.notation.upperBonusValue : 0
        return u + bonus
    }

    // MARK: - Middle
    static func middleTotal(sc: Scorecard, game: Game, col: Int) -> Int {
        let maxV = norm(sc.maxVals[col])
        let minV = norm(sc.minVals[col])
        switch game.notation.middleMode {
        case .multiplier:
            let aces = norm(sc.ones[col]) // #As (0..5)
            return (maxV - minV) * aces
        case .bonusGate:
            var s = maxV + minV
            if maxV > minV && s >= game.notation.middleBonusSumThreshold {
                s += game.notation.middleBonusValue
            }
            return s
        }
    }

    // MARK: - Bottom helpers
    private static func applyFigureRule(_ raw: Int, rule: FigureRule) -> Int {
        if raw <= 0 { return 0 } // 0 => barré, -1 => vide
        switch rule.mode {
        case .raw:           return raw
        case .fixed:         return rule.fixedValue
        case .rawPlusFixed:  return raw + rule.fixedValue
        case .rawTimes:      return raw * max(1, rule.multiplier)
        }
    }

    private static func val(_ arr: [Int], _ col: Int) -> Int {
        guard col >= 0, col < arr.count else { return 0 }
        let v = arr[col]
        return v >= 0 ? v : 0
    }

    /// Score pour la grande suite: on utilise la valeur **stockée**, pas un mapping 15/20
    static func suiteScore(sc: Scorecard, col: Int) -> Int {
        return val(sc.suite, col)
    }

    /// Score pour la petite suite: idem, valeur **stockée** (0 ou la valeur définie dans la Notation)
    static func petiteSuiteScore(sc: Scorecard, col: Int) -> Int {
        return val(sc.petiteSuite, col)
    }

    static func bottomTotal(sc: Scorecard, game: Game, col: Int) -> Int {
        let n = game.notation

        let brelan       = applyFigureRule(sc.brelan[col],       rule: n.ruleBrelan)
        let chance       = game.enableChance
                            ? applyFigureRule(sc.chance[col],    rule: n.ruleChance)
                            : 0
        let full         = applyFigureRule(sc.full[col],         rule: n.ruleFull)

        // Les valeurs de Suite/Petite suite sont désormais *déjà finales* (0 ou valeur de la Notation)
        let suite        = suiteScore(sc: sc, col: col)
        let petiteSuite  = game.enableSmallStraight ? petiteSuiteScore(sc: sc, col: col) : 0

        let carre        = applyFigureRule(sc.carre[col],        rule: n.ruleCarre)
        let yams         = applyFigureRule(sc.yams[col],         rule: n.ruleYams)

        // >>> prime centralisée ici, UNE SEULE FOIS
        let extra        = extraYamsBonusAmount(sc: sc, game: game, col: col)

        return brelan + chance + full + suite + petiteSuite + carre + yams + extra
    }

    static func total(sc: Scorecard, game: Game, col: Int) -> Int {
        upperTotal(sc: sc, game: game, col: col)
        + middleTotal(sc: sc, game: game, col: col)
        + bottomTotal(sc: sc, game: game, col: col)
    }

    // MARK: - Tooltips
    static func middleTooltip(mode: MiddleRuleMode, threshold: Int, bonus: Int) -> String {
        switch mode {
        case .multiplier:
            return "Multiplier : (Max − Min) × nombre d’As."
        case .bonusGate:
            return "BonusGate : si Max > Min et Max+Min ≥ \(threshold) ⇒ +\(bonus)."
        }
    }

    static func figureTooltip(notation n: NotationSnapshot, figure: FigureKind) -> String {
        func desc(_ r: FigureRule) -> String {
            switch r.mode {
            case .raw:           return "Somme saisie."
            case .fixed:         return "Valeur fixe : \(r.fixedValue)."
            case .rawPlusFixed:  return "Somme saisie + prime fixe \(r.fixedValue)."
            case .rawTimes:      return "Somme saisie × multiplicateur \(max(1, r.multiplier))."
            }
        }
        switch figure {
        case .brelan:      return "Brelan — " + desc(n.ruleBrelan)
        case .chance:      return "Chance — " + desc(n.ruleChance)
        case .full:        return "Full — " + desc(n.ruleFull)
        case .carre:       return "Carré — " + desc(n.ruleCarre)
        case .yams:
            let base = "Yams — " + desc(n.ruleYams)
            return n.extraYamsBonusEnabled ? base + " (+\(n.extraYamsBonusValue) bonus si Yams)" : base
        case .suiteBig:
            switch n.suiteBigMode {
            case .singleFixed:
                return "Suite (5 dés) — Valeur fixe : \(n.suiteBigFixed). (1–5 ou 2–6)"
            case .splitFixed:
                return "Suite (5 dés) — 1–5 : \(n.suiteBigFixed1to5) ; 2–6 : \(n.suiteBigFixed2to6)."
            }
        case .petiteSuite:
            return "Petite suite (4 dés) — " + desc(n.rulePetiteSuite)
        }
    }
}



================================================================================
FILE: YamSheet/Models/StatsModels.swift
================================================================================

//
//  StatsModels.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 21/09/2025.
//
import Foundation

struct PlayerStats: Identifiable, Hashable {
    var id: UUID { playerID }
    let playerID: UUID
    let name: String

    let gamesPlayed: Int
    let wins: Int
    var winRate: Double { gamesPlayed > 0 ? Double(wins) / Double(gamesPlayed) : 0 }

    let avgScore: Double
    let bestScore: Int
    let worstScore: Int
    let yamsRate: Double

    // 👉 Historique des scores pour les graphiques
    let scoresHistory: [Int]
}

struct AppStats {
    let totalGames: Int
    let completedGames: Int
    let totalPlayers: Int

    let bestScoreEver: (name: String, score: Int)?
    /// Classement global (du meilleur au moins bon) : (nom, meilleur score)
    let leaderboardTop: [(name: String, bestScore: Int)]

    let mostWins: (name: String, wins: Int)?
}



================================================================================
FILE: YamSheet/Persistence/SampleData.swift
================================================================================

import Foundation
import SwiftData

struct SampleData {
    static func ensureSamples(_ context: ModelContext) {
        //let playersCount = (try? context.fetch(FetchDescriptor<Player>()))?.count ?? 0
        //if playersCount == 0 {
            //context.insert(Player(name: "Alice Dupont", nickname: "Ali"))
            //context.insert(Player(name: "Bruno Martin", nickname: "Bru"))
            //context.insert(Player(name: "Chloé Petit", nickname: "Clo"))
            //try? context.save()
        //}
        
        //let notationsCount = (try? context.fetch(FetchDescriptor<Notation>()))?.count ?? 0
        /*if notationsCount == 0 {
            let classic = Notation(
                name: "Classique",
                tooltipUpper: "Atteindre 63 points en haut donne un bonus.",
                tooltipMiddle: "Règle bonus: Max>Min et Max+Min ≥ seuil ⇒ +bonus.",
                tooltipBottom: "Full/Carré/Yams = somme + prime fixe.",
                upperBonusThreshold: 63,
                upperBonusValue: 35,
                middleMode: .bonusGate,
                middleBonusSumThreshold: 50,
                middleBonusValue: 30,
                ruleBrelan: FigureRule(mode: .raw),
                ruleChance: FigureRule(mode: .raw),
                ruleFull: FigureRule(mode: .rawPlusFixed, fixedValue: 30),
                ruleSuite: FigureRule(mode: .fixed, fixedValue: 15),
                rulePetiteSuite: FigureRule(mode: .fixed, fixedValue: 10),
                ruleCarre: FigureRule(mode: .rawPlusFixed, fixedValue: 40),
                ruleYams: FigureRule(mode: .rawPlusFixed, fixedValue: 50),
                extraYamsBonusEnabled: true,
                extraYamsBonusValue: 100
            )
            context.insert(classic)
            try? context.save()
        }*/

    }
}



================================================================================
FILE: YamSheet/Services/StatsService.swift
================================================================================

//
//  StatsService.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 21/09/2025.
//

import Foundation

enum StatsService {

    // MARK: - Totaux

    /// Score total (toutes sections + extra yams)
    /// Par défaut on travaille en colonne 0 (score simple colonne).
    static func total(for sc: Scorecard, game: Game, col: Int = 0) -> Int {
        StatsEngine.total(sc: sc, game: game, col: col)
    }

    // MARK: - Stats par joueur

    /// Calcule les statistiques par joueur à partir des parties **terminées**.
    /// Optimisé : pré-calcul des totaux (gameID × playerID) pour éviter les recalculs.
    static func playerStats(allPlayers: [Player], games: [Game]) -> [PlayerStats] {
        let playersByID = Dictionary(uniqueKeysWithValues: allPlayers.map { ($0.id, $0) })
        let completed = games.filter { $0.statusOrDefault == .completed }

        // 1) Pré-calcul des totaux par (gameID, playerID)
        var totalByGamePlayer: [ObjectIdentifier: [UUID: Int]] = [:]
        for g in completed {
            let gid = ObjectIdentifier(g)
            totalByGamePlayer[gid] = Dictionary(uniqueKeysWithValues:
                g.scorecards.map { sc in (sc.playerID, total(for: sc, game: g)) }
            )
        }

        // 2) Accumulation sans recalculer
        var acc: [UUID: (scores: [Int], wins: Int, yamsHits: Int, gamesPlayed: Int, name: String)] = [:]

        for g in completed {
            let gid = ObjectIdentifier(g)
            guard let row = totalByGamePlayer[gid] else { continue }

            // Gagnants de la partie (égalité supportée)
            let totals = row.map { (pid: $0.key, total: $0.value) }
            let top = totals.map { $0.total }.max() ?? 0
            let winners = Set(totals.filter { $0.total == top }.map { $0.pid })

            for sc in g.scorecards {
                let pid = sc.playerID
                let name = playersByID[pid]?.nickname ?? "—"

                var e = acc[pid] ?? (scores: [], wins: 0, yamsHits: 0, gamesPlayed: 0, name: name)
                let t = row[pid] ?? 0

                e.scores.append(t)
                e.gamesPlayed += 1
                if winners.contains(pid) { e.wins += 1 }

                // Yams > 0 en colonne 0 ?
                let yamsVal = (0 < sc.yams.count) ? sc.yams[0] : -1
                if yamsVal > 0 { e.yamsHits += 1 }

                e.name = name
                acc[pid] = e
            }
        }

        return acc.map { (pid, s) in
            let played = s.gamesPlayed
            let sum = s.scores.reduce(0, +)
            let avg = played > 0 ? Double(sum) / Double(played) : 0
            let best = s.scores.max() ?? 0
            let worst = s.scores.min() ?? 0
            let yRate = played > 0 ? Double(s.yamsHits) / Double(played) : 0

            return PlayerStats(
                playerID: pid,
                name: s.name,
                gamesPlayed: played,
                wins: s.wins,
                avgScore: avg,
                bestScore: best,
                worstScore: worst,
                yamsRate: yRate,
                scoresHistory: s.scores
            )
        }
        .sorted { $0.bestScore > $1.bestScore }
    }


    // MARK: - Extra Yams (primes)

    /// Nombre de primes de Yams par joueur (compte les parties où une prime a été attribuée au moins une fois).
    /// Hypothèse de modèle: `Scorecard.extraYams` contient, par colonne, un entier > 0 si une prime a été attribuée.
    static func yamsPrimesByPlayer(games: [Game], col: Int = 0) -> [UUID: Int] {
        let completed = games.filter { $0.statusOrDefault == .completed }
        var acc: [UUID: Int] = [:]
        for g in completed {
            for sc in g.scorecards {
                // Safe lookup via reflection: if Scorecard has a property named "extraYams" of type [Int], use it.
                let mirror = Mirror(reflecting: sc)
                let extra: [Int]? = mirror.children.first(where: { $0.label == "extraYams" })?.value as? [Int]
                if let arr = extra, col < arr.count, arr[col] > 0 {
                    acc[sc.playerID, default: 0] += 1
                }
            }
        }
        return acc
    }

    /// Nombre de primes de Yams pour un joueur donné.
    static func yamsPrimesCount(for playerID: UUID, games: [Game], col: Int = 0) -> Int {
        yamsPrimesByPlayer(games: games, col: col)[playerID] ?? 0
    }

    // MARK: - Stats globales

    /// Statistiques générales de l’application (sur parties terminées).
    static func appStats(allPlayers: [Player], games: [Game]) -> AppStats {
        let completed = games.filter { $0.statusOrDefault == .completed }

        var bestEver: (name: String, score: Int)? = nil
        var bestByPlayer: [UUID: Int] = [:]
        var winsByPlayer: [UUID: Int] = [:]

        for g in completed {
            // Totaux de la partie
            let totals = g.scorecards.map { (pid: $0.playerID, total: total(for: $0, game: g)) }

            // Meilleur score de la partie (pour bestEver + wins)
            if let max = totals.max(by: { $0.total < $1.total }) {
                // Best ever (record global)
                if bestEver == nil || max.total > bestEver!.score {
                    let winnerName = allPlayers.first(where: { $0.id == max.pid })?.nickname
                        ?? g.scorecards.first(where: { $0.playerID == max.pid }).map { _ in "—" }
                        ?? "—"
                    bestEver = (winnerName, max.total)
                }

                // Victoires : tous les ex-aequo en tête marquent 1 win
                let top = totals.map { $0.total }.max() ?? max.total
                for t in totals where t.total == top {
                    winsByPlayer[t.pid, default: 0] += 1
                }
            }

            // Meilleur score par joueur (perso)
            for sc in g.scorecards {
                let t = total(for: sc, game: g)
                bestByPlayer[sc.playerID] = max(bestByPlayer[sc.playerID] ?? 0, t)
            }
        }

        // Leaderboard = meilleurs scores personnels
        let leaderboard: [(name: String, bestScore: Int)] = bestByPlayer.compactMap { (pid, score) in
            guard let name = allPlayers.first(where: { $0.id == pid })?.nickname else { return nil }
            return (name, score)
        }
        .sorted { $0.bestScore > $1.bestScore }

        // Joueur avec le plus de victoires
        let mostWins: (name: String, wins: Int)? = winsByPlayer
            .max(by: { $0.value < $1.value })
            .flatMap { (pid, w) in
                if let name = allPlayers.first(where: { $0.id == pid })?.nickname {
                    return (name, w)
                }
                return nil
            }

        return AppStats(
            totalGames: games.count,
            completedGames: completed.count,
            totalPlayers: allPlayers.count,
            bestScoreEver: bestEver,
            leaderboardTop: leaderboard,
            mostWins: mostWins
        )
    }
}



================================================================================
FILE: YamSheet/Services/StatsStore.swift
================================================================================

//
//  StatsStore.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 23/09/2025.
//

import Foundation
@preconcurrency import SwiftData
import Combine

// Explicitly declare a box that we assert is safe to send across Task boundaries
private struct UnsafeSendable<T>: @unchecked Sendable { let value: T }

@MainActor
final class StatsStore: ObservableObject {
    @Published private(set) var playerStats: [PlayerStats] = []
    @Published private(set) var appStats: AppStats? = nil

    private var calcTask: Task<Void, Never>?
    private var lastFingerprint: String = ""

    func refresh(players: [Player], games: [Game]) {
        // Empêche recalcul si rien n’a changé (fingerprint léger)
        let fp = Self.fingerprint(players: players, games: games)
        guard fp != lastFingerprint else { return }
        lastFingerprint = fp

        calcTask?.cancel()
        let p = UnsafeSendable(value: players)
        let g = UnsafeSendable(value: games)
        calcTask = Task { [p, g] in
            // Petit debounce pour regrouper les rafales de changements
            try? await Task.sleep(nanoseconds: 150_000_000) // 150ms

            // Calcul en tâche de fond
            let result = Self.compute(players: p.value, games: g.value)
            guard !Task.isCancelled else { return }

            self.playerStats = result.playerStats
            self.appStats = result.appStats
        }
    }

    private static func fingerprint(players: [Player], games: [Game]) -> String {
        // très léger : nb joueurs, nb parties, nb complétées, dernières dates
        let p = players.count
        let g = games.count
        let gc = games.filter { $0.statusOrDefault == .completed }.count
        let lastGameEdit = games.compactMap { $0.endedAt ?? $0.startedAt }.max() ?? .distantPast
        return "\(p)-\(g)-\(gc)-\(lastGameEdit.timeIntervalSince1970)"
    }

    private static func compute(players: [Player], games: [Game]) -> (playerStats: [PlayerStats], appStats: AppStats) {
        // Calcul pur (aucun accès UI / MainActor)
        let ps = StatsService.playerStats(allPlayers: players, games: games)
        let asg = StatsService.appStats(allPlayers: players, games: games)
        return (ps, asg)
    }
}



================================================================================
FILE: YamSheet/Support/AppEvents.swift
================================================================================

//
//  AppEvents.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 10/09/2025.
//

import Foundation

extension Notification.Name {
    /// À poster quand GameDetailView doit fermer toute la pile et revenir à la liste
    static let closeToGamesList = Notification.Name("closeToGamesList")
}



================================================================================
FILE: YamSheet/Support/Compat.swift
================================================================================

//
//  Compat.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 11/09/2025.
//

import SwiftUI

extension View {
    @ViewBuilder
    func onChangeCompat<T: Equatable>(_ value: T, perform: @escaping () -> Void) -> some View {
        if #available(iOS 17.0, *) {
            self.onChange(of: value) { _, _ in perform() }
        } else {
            self.onChange(of: value) { _ in perform() }
        }
    }
}



================================================================================
FILE: YamSheet/Support/DebugKit/DebugConfig.swift
================================================================================

//
//  DebugConfig.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 30/09/2025.
//

#if DEBUG
import Foundation

enum DebugKeys {
    static let debugMode   = "debugMode"       // ON/OFF global
    static let verboseLogs = "debugVerbose"    // logs verbeux via DLog
    static let autoSeed    = "debugAutoSeed"   // seed auto au lancement
}

enum DebugConfig {
    // Lecture des préférences (pilotées par Settings)
    static var isOn: Bool { UserDefaults.standard.bool(forKey: DebugKeys.debugMode) }
    static var verboseLogs: Bool { isOn && UserDefaults.standard.bool(forKey: DebugKeys.verboseLogs) }
    static var autoSeedOnLaunch: Bool { isOn && UserDefaults.standard.bool(forKey: DebugKeys.autoSeed) }
}
#endif



================================================================================
FILE: YamSheet/Support/DebugKit/DebugLog.swift
================================================================================

//
//  DebugLog.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 30/09/2025.
//

#if DEBUG
import Foundation

func DLog(_ message: @autoclosure () -> String,
          file: StaticString = #fileID,
          function: StaticString = #function,
          line: UInt = #line) {
    guard DebugConfig.verboseLogs else { return }
    print("🔹[DEBUG] \(file):\(line) \(function) — \(message())")
}
#endif



================================================================================
FILE: YamSheet/Support/DebugKit/DebugSettingsView.swift
================================================================================

//
//  DebugSettingsView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/10/2025.
//

#if DEBUG
import SwiftUI
import SwiftData

struct DebugSettingsView: View {
    @AppStorage(DebugKeys.debugMode)   private var debugMode: Bool = false
    @AppStorage(DebugKeys.verboseLogs) private var verboseLogs: Bool = true
    @AppStorage(DebugKeys.autoSeed)    private var autoSeed: Bool = true

    @Environment(\.modelContext) private var context

    var body: some View {
        Form {
            Section {
                Toggle("Activer le mode Debug", isOn: $debugMode)
            } footer: {
                Text("Le mode Debug n’est disponible qu’en build DEBUG. En production, ces options sont inactives.")
            }

            if debugMode {
                Section("Options Debug") {
                    Toggle("Logs verbeux (DLog)", isOn: $verboseLogs)
                    Toggle("Seed auto au lancement", isOn: $autoSeed)
                }

                Section("Actions") {
                    Button("Wipe + Seed de démo") {
                        wipeAllData(context)
                        DevSeed.seedIfNeeded(context)
                    }
                    .foregroundStyle(.red)
                }
            }
        }
        .navigationTitle("Debug")
    }

    private func wipeAllData(_ ctx: ModelContext) {
        do {
            let allPlayers = try ctx.fetch(FetchDescriptor<Player>())
            let allGames   = try ctx.fetch(FetchDescriptor<Game>())
            allPlayers.forEach { ctx.delete($0) }
            allGames.forEach { ctx.delete($0) }
            try ctx.save()
        } catch {
            print("Wipe error: \(error)")
        }
    }
}
#endif



================================================================================
FILE: YamSheet/Support/DevSeed.swift
================================================================================

//
//  DevSeed.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 29/09/2025.
//

#if DEBUG
import SwiftUI
import SwiftData

/// Seed de démo (DEBUG) : joueurs + parties complétées
enum DevSeed {
    static func seedIfNeeded(_ context: ModelContext) {
        // 0) Si on a déjà des données, on ne fait rien
        let existingPlayers = (try? context.fetch(FetchDescriptor<Player>())) ?? []
        let existingGames   = (try? context.fetch(FetchDescriptor<Game>())) ?? []
        guard existingPlayers.isEmpty && existingGames.isEmpty else { return }

        // 1) Joueurs
        let players: [Player] = [
            Player(name: "Alice Martin",   nickname: "Alice", email: "alice@example.com",  favoriteEmoji: "🦊", color: .orange),
            Player(name: "Benoît Leroy",   nickname: "Ben",   email: "ben@example.com",    favoriteEmoji: "🐻", color: .blue),
            Player(name: "Chloé Bernard",  nickname: "Chloé", email: "chloe@example.com",  favoriteEmoji: "🦋", color: .pink),
            Player(name: "David Nguyen",   nickname: "David", email: "david@example.com",  favoriteEmoji: "🐯", color: .green),
            Player(name: "Emma Dupont",    nickname: "Emma",  email: "emma@example.com",   favoriteEmoji: "🦄", color: .purple),
            Player(name: "Farid Karim",    nickname: "Farid", email: "farid@example.com",  favoriteEmoji: "🐼", color: .teal),
        ]
        players.forEach { context.insert($0) }

        // 2) Settings + Notation défaut
        // 🔧 Si AppSettings() n'existe pas, remplace par ton fetch ou init custom
        let settings = AppSettings()
        let notation = makeDefaultNotation(from: settings)

        // 3) Parties complétées
        let gamesCount = 12
        for i in 0..<gamesCount {
            let columns = 1

            // Groupe 2–5 joueurs
            let group = Array(players.shuffled().prefix(Int.random(in: 2...5)))
            let pids  = group.map { $0.id }

            // Scorecards (colonne unique = index 0)
            var scorecards: [Scorecard] = []
            for pl in group {
                var sc = Scorecard(playerID: pl.id, columns: columns)

                // Section haute
                set(sc: &sc, key: \.onesData,   values: [randomUpper(face: 1)])
                set(sc: &sc, key: \.twosData,   values: [randomUpper(face: 2)])
                set(sc: &sc, key: \.threesData, values: [randomUpper(face: 3)])
                set(sc: &sc, key: \.foursData,  values: [randomUpper(face: 4)])
                set(sc: &sc, key: \.fivesData,  values: [randomUpper(face: 5)])
                set(sc: &sc, key: \.sixesData,  values: [randomUpper(face: 6)])

                // Section milieu (Max/Min)
                set(sc: &sc, key: \.maxValsData, values: [Int.random(in: 18...30)])
                set(sc: &sc, key: \.minValsData, values: [Int.random(in: 5...15)])

                // Section basse
                set(sc: &sc, key: \.brelanData, values: [Bool.random() ? Int.random(in: 12...25) : 0])
                set(sc: &sc, key: \.chanceData, values: [Int.random(in: 12...30)])
                set(sc: &sc, key: \.fullData,   values: [Bool.random() ? notation.ruleFull.fixedValue : 0])
                set(sc: &sc, key: \.carreData,  values: [Int.random(in: 4...30)]) // carré : 4…30

                // Grande suite (split 1–5 / 2–6 / barré) selon ta notation
                let pick = Int.random(in: 0...2)
                let suiteVal: Int = {
                    switch pick {
                    case 0: return 0
                    case 1: return notation.suiteBigFixed1to5
                    default: return notation.suiteBigFixed2to6
                    }
                }()
                set(sc: &sc, key: \.suiteData, values: [suiteVal])

                // Petite suite
                set(sc: &sc, key: \.petiteSuiteData, values: [settings.enableSmallStraight ? settings.smallStraightScore : 0])

                // Yams + prime
                let yamsOK = Bool.random() && Bool.random()
                let yamsScore = yamsOK ? notation.ruleYams.fixedValue : 0
                set(sc: &sc, key: \.yamsData, values: [yamsScore])
                sc.extraYamsAwarded = [ yamsOK && notation.extraYamsBonusEnabled && Bool.random() ]

                scorecards.append(sc)
            }

            // Game inProgress par défaut via init — on passe en "completed"
            var g = Game(settings: settings, notation: notation, columns: columns, comment: "Partie #\(i+1)")

            // 🔗 Liaison aux joueurs/scorecards (adapte les noms si différents dans ton modèle)
            // Ces propriétés existent déjà dans ton code ailleurs, on les affecte donc ici :
            // - participantIDs
            // - scorecards
            // - activePlayerID
            // - statusRaw (pour marquer complétée)
            g.participantIDs = pids
            g.scorecards = scorecards
            g.statusRaw = GameStatus.completed.rawValue

            context.insert(g)
        }

        try? context.save()
        print("✅ DevSeed: \(players.count) joueurs / \(gamesCount) parties injectées")
    }

    // MARK: - Notation par défaut (basée sur ce que tu as partagé)
    private static func makeDefaultNotation(from s: AppSettings) -> NotationSnapshot {
        NotationSnapshot(
            name: "Par défaut",
            tooltipUpper: "Atteindre \(s.upperBonusThreshold) en haut donne +\(s.upperBonusValue).",
            tooltipMiddle: "Multiplier : (Max − Min) × nombre d’As.",
            tooltipBottom: "Figures calculées selon la saisie (somme/prime).",
            upperBonusThreshold: s.upperBonusThreshold,
            upperBonusValue: s.upperBonusValue,
            middleMode: .multiplier,
            middleBonusSumThreshold: 50,
            middleBonusValue: 30,
            // Règles
            ruleBrelan: FigureRule(mode: .raw),
            ruleChance: FigureRule(mode: .raw),
            ruleFull: FigureRule(mode: .rawPlusFixed, fixedValue: 30),
            ruleSuite: FigureRule(mode: .fixed, fixedValue: 0), // non utilisé avec SuiteBig
            rulePetiteSuite: FigureRule(mode: .fixed, fixedValue: s.enableSmallStraight ? s.smallStraightScore : 0),
            ruleCarre: FigureRule(mode: .rawPlusFixed, fixedValue: 40),
            ruleYams: FigureRule(mode: .rawPlusFixed, fixedValue: 50),
            // Grande suite en split
            suiteBigMode: .splitFixed,
            suiteBigFixed: 0,
            suiteBigFixed1to5: 15,
            suiteBigFixed2to6: 20,
            // Bonus yams sup
            extraYamsBonusEnabled: false,
            extraYamsBonusValue: 0
        )
    }

    // MARK: - Utilitaires d'encodage pour Scorecard.*Data
    private static func encodeJSON<T: Encodable>(_ value: T) -> Data {
        (try? JSONEncoder().encode(value)) ?? Data()
    }
    private static func set(sc: inout Scorecard, key: WritableKeyPath<Scorecard, Data>, values: [Int]) {
        sc[keyPath: key] = encodeJSON(values)
    }
    private static func randomUpper(face: Int) -> Int {
        // -1 = vide, 0 = barré, sinon multiple de face (on évite -1 pour nourrir les stats)
        if Bool.random() { return 0 }
        return face * Int.random(in: 1...3)
    }
}
#endif



================================================================================
FILE: YamSheet/Support/LottieSupport.swift
================================================================================

//
//  LottieSupport.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 08/09/2025.
//
import SwiftUI

#if canImport(Lottie)
import Lottie

// MARK: - Loader robuste (racine + sous-dossier)
enum LottieLoader {
    static func load(named name: String, subdirectory: String? = nil, bundle: Bundle = .main) -> LottieAnimation? {
        // 1) racine
        if let a = LottieAnimation.named(name, bundle: bundle) { return a }
        // 2) sous-dossier explicite (ex: "Resources" si dossier BLEU)
        if let sub = subdirectory, let a = LottieAnimation.named(name, bundle: bundle, subdirectory: sub) { return a }
        // 3) fallback: chemins explicites
        for dir in [subdirectory, "Resources", nil] {
            if let path = bundle.path(forResource: name, ofType: "json", inDirectory: dir) {
                return LottieAnimation.filepath(path)
            }
        }
        #if DEBUG
        print("[LottieLoader] ❌ Échec chargement '\(name)' (subdir=\(subdirectory ?? "nil"))")
        #endif
        return nil
    }

    @discardableResult
    static func listJSONs(in bundle: Bundle = .main) -> [String] {
        let paths = bundle.paths(forResourcesOfType: "json", inDirectory: nil).sorted()
        #if DEBUG
        print("[LottieLoader] JSON dans bundle:\n" + paths.joined(separator: "\n"))
        #endif
        return paths
    }
}

// MARK: - UIViewRepresentable
struct LottieView: UIViewRepresentable {
    let name: String
    var loopMode: LottieLoopMode = .playOnce
    var speed: CGFloat = 1.0
    var subdirectory: String? = nil

    func makeUIView(context: Context) -> LottieAnimationView {
        let v = LottieAnimationView()
        v.backgroundBehavior = .pauseAndRestore
        v.contentMode = .scaleAspectFill
        v.loopMode = loopMode
        v.animationSpeed = speed
        v.backgroundColor = .clear          // important
        v.isOpaque = false
        v.animation = LottieLoader.load(named: name, subdirectory: subdirectory)

        // lancer après layout
        DispatchQueue.main.async {
            if v.animation != nil {
                #if DEBUG
                print("[LottieView] ▶️ play '\(name)'")
                #endif
                v.play()
            } else {
                #if DEBUG
                print("[LottieView] ⚠️ animation == nil pour '\(name)'")
                #endif
            }
        }
        return v
    }

    func updateUIView(_ uiView: LottieAnimationView, context: Context) {
        if uiView.animation != nil, !uiView.isAnimationPlaying {
            uiView.play()
        }
    }
}

// MARK: - Vue aléatoire robuste (filtre les chargeables)
struct LottieRandomCelebrationView: View {
    let names: [String]             // sans .json
    var loopOnce: Bool = true
    var speed: CGFloat = 1.0
    var subdirectory: String? = nil // "Resources" si dossier BLEU

    @State private var picked: String?

    var body: some View {
        Group {
            if let p = picked {
                LottieView(name: p,
                           loopMode: loopOnce ? .playOnce : .loop,
                           speed: speed,
                           subdirectory: subdirectory)
            } else {
                // Fallback visuel si rien de chargeable
                #if DEBUG
                Text("⚠️ Aucune animation Lottie chargeable").font(.caption).padding(8)
                    .background(.red.opacity(0.85)).clipShape(Capsule()).foregroundStyle(.white)
                #else
                Color.clear
                #endif
            }
        }
        .onAppear {
            // filtre les animations réellement chargeables
            let ok = names.filter { LottieLoader.load(named: $0, subdirectory: subdirectory) != nil }
            #if DEBUG
            print("[LottieRandom] chargeables =", ok)
            if ok.isEmpty { _ = LottieLoader.listJSONs() }
            #endif
            picked = ok.randomElement()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .allowsHitTesting(false)
    }
}

#else   // --- fallback quand Lottie n'est pas attaché au target ---

struct LottieView: View {
    let name: String
    var loopMode: Int = 0
    var speed: CGFloat = 1.0
    var subdirectory: String? = nil
    var body: some View { Color.clear }
}

struct LottieRandomCelebrationView: View {
    let names: [String]; var loopOnce: Bool = true; var speed: CGFloat = 1.0; var subdirectory: String? = nil
    var body: some View { Color.clear }
}

#endif

// MARK: - (DEBUG) Inspecteur simple
#if DEBUG && canImport(Lottie)
struct LottieBundleInspectorView: View {
    @State private var jsons: [String] = []
    @State private var showPreview = false
    @State private var selection: String?

    var body: some View {
        NavigationStack {
            List(jsons, id: \.self) { path in
                let name = URL(fileURLWithPath: path).deletingPathExtension().lastPathComponent
                Button {
                    selection = name; showPreview = true
                } label: {
                    VStack(alignment: .leading, spacing: 2) {
                        Text(name)
                        Text(path).font(.caption2).foregroundStyle(.secondary)
                    }
                }
            }
            .navigationTitle("Lottie Inspector")
            .onAppear { jsons = LottieLoader.listJSONs() }
            .sheet(isPresented: $showPreview) {
                VStack {
                    Text(selection ?? "—").font(.headline)
                    if let n = selection {
                        LottieView(name: n).frame(maxWidth: .infinity, maxHeight: .infinity)
                    } else {
                        Color.clear
                    }
                }
                .presentationDetents([.medium, .large])
            }
        }
    }
}
#endif



================================================================================
FILE: YamSheet/Utils/KeyboardHelpers.swift
================================================================================

//
//  KeyboardHelpers.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 01/09/2025.
//

import SwiftUI

public extension View {
    func hideKeyboard() {
        #if canImport(UIKit)
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder),
                                        to: nil, from: nil, for: nil)
        #endif
    }
}



================================================================================
FILE: YamSheet/Utils/LocationHelper.swift
================================================================================

import Foundation
import CoreLocation

/// Placeholder for future geolocation logic.
struct LocationHelper {
    static func currentCountryCode() -> String? {
        return Locale.current.region?.identifier
    }
}



================================================================================
FILE: YamSheet/Utils/NotificationManager.swift
================================================================================

//
//  NotificationManager.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 06/09/2025.
//

import Foundation
import UserNotifications

enum NotificationManager {
    /// À appeler tôt (ex: onAppear d’un écran principal) pour demander l’autorisation.
    static func requestAuthorizationIfNeeded() {
        let center = UNUserNotificationCenter.current()
        center.getNotificationSettings { settings in
            guard settings.authorizationStatus == .notDetermined else { return }
            center.requestAuthorization(options: [.alert, .badge, .sound]) { _, _ in }
        }
    }

    /// Déclenche une notif locale immédiate pour la fin de partie (si l’app est en arrière-plan).
    static func postEndGame(winnerName: String, gameName: String?, rankings: [(String, Int)]) {
        let content = UNMutableNotificationContent()
        content.title = "Partie terminée 🎉"
        //let gName = (gameName?.isEmpty == false) ? " «\(gameName!)»" : ""
        content.subtitle = "Bravo \(winnerName) !"
        let top3 = rankings.prefix(3)
            .enumerated()
            .map { "\($0.offset + 1). \($0.element.0) — \($0.element.1)" }
            .joined(separator: "   ")
        content.body = top3.isEmpty ? "Tou·te·s les scores sont enregistrés." : top3
        content.sound = .default

        let req = UNNotificationRequest(
            identifier: UUID().uuidString,
            content: content,
            trigger: nil // immédiat
        )
        UNUserNotificationCenter.current().add(req, withCompletionHandler: nil)
    }
}




================================================================================
FILE: YamSheet/Utils/UIStrings.swift
================================================================================

//
//  UIStrings.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/08/2025.
//

import Foundation

enum UIStrings {
    enum Common {
        static let ok         = "OK"
        static let cancel     = "Annuler"
        static let save       = "Enregistrer"
        static let create     = "Créer"
        static let delete     = "Supprimer"
        static let validate   = "Valider"
        static let clear      = "Effacer"
        static let dash       = "—"
        static let creat       = "Créer"
        static let games       = "Parties"
        static let over       = "Terminée"
        static let inprogress       = "En cours"
        static let game       = "Partie"
        static let players     = "Joueurs"
        static let settings     = "Paramètres"
        static let notations    = "Notations"
        static let toadd    = "Ajouter"
        static let stats    = "Stats"
        static let avg    = "Moyenne"
        static let best    = "Meilleur"
        static let worst    = "Pire"
        static let wins    = "Victoires"
        static let losses    = "Défaites"
        static let identity    = "Identité"
        
     
    }
    


    enum Game {
        static let title          = "Feuille de score"

        // Sections
        static let upperSection   = "Section haute"
        static let middleSection  = "Section milieu"
        static let bottomSection  = "Section basse"
        
        //Totals
        static let total1 = "Total 1"
        static let total2 = "Total 2"
        static let total3 = "Total 3"
        static let totalAll = "Total général"

        // Header menu
        static let pause          = "Pause"
        static let resume         = "Reprendre"
        static let finish         = "Terminer"

        // Upper labels
        static let ones   = "As (1)"
        static let twos   = "Deux (2)"
        static let threes = "Trois (3)"
        static let fours  = "Quatre (4)"
        static let fives  = "Cinq (5)"
        static let sixes  = "Six (6)"

        // Middle labels
        static let max    = "Max"
        static let min    = "Min"

        // Bottom labels
        static let brelan       = "Brelan"
        static let chance       = "Chance"
        static let full         = "Full"
        static let carre        = "Carré"
        static let yams         = "Yams"
        static let suite        = "Suite"
        static let petiteSuite  = "Petite suite"

        // Tooltip
        static let tooltipTitle = "Info notation"

        // Picker display
        static let barred0   = "0"
        static let suite15   = "15"
        static let suite20   = "20"
        static let petiteLbl = "Petite suite"
    }

    enum Notation {
        static let tabTitle      = "Notations"
        static let name          = "Nom"
        static let tooltips      = "Tooltips"
        static let tooltipUpper  = "Upper (explication bonus)"
        static let tooltipMiddle = "Milieu (explication règles)"
        static let tooltipBottom = "Basse (explication figures)"
        static let upperSection  = "Section haute"
        static let middleSection = "Section milieu"
        static let bottomRules   = "Section basse — règles"
        static let upperBonusThresholdLabel = "Seuil bonus haut"
        static let upperBonusLabel          = "Bonus haut"
        static let modeLabel                = "Mode"
        static let figureTooltipPlaceholder = "Tooltip (optionnel)"

        //Upper option
        static let upperBonusthresholdLab  = "Seuil bonus haut pouet2"
        static let upperBonusOnlab  = "Seuil bonus haut pouet2"
        
        // Middle options
        static let rulePicker    = "Règle"
        static let thresholdSum  = "Seuil somme (Max+Min)"
        static let bonus         = "Bonus"

        // Bottom figure rows
        static let valueFixed    = "Valeur fixe"
        static let primeFixed    = "Prime fixe"
        static let multiplier    = "Multiplicateur"

        // Suite
        static let bigSuite      = "Grande suite (5 dés)"
        static let suite15Lbl    = "Suite 1–5"
        static let suite20Lbl    = "Suite 2–6"

        // Yams bonus
        static let extraYamsOn   = "Prime Yams supplémentaire"
        static let extraYams     = "Bonus Yams"

        // List hints
        static let listUpperLine = "Haut : Bonus +%d si ≥ %d"
        static let listMiddle    = "Milieu : %@"
        static let listBottom    = "Bas : tapote une figure pour son détail"
        
        // Libellés des modes (section milieu)
        static let middleLabelMultiplier = "Multiplicateur"
        static let middleLabelBonusGate  = "Bonus au 50"
        static func middleLabel(_ mode: MiddleRuleMode) -> String {
            switch mode {
            case .multiplier: return middleLabelMultiplier
            case .bonusGate:  return middleLabelBonusGate
            }
        }

        // Libellés des modes (section basse)
        static let bottomLabelRaw          = "Somme des dés"
        static let bottomLabelFixed        = "Valeur fixe"
        static let bottomLabelRawPlusFixed = "Somme + Prime"
        static let bottomLabelRawTimes     = "Somme × multiplicateur"
        static func bottomLabel(_ mode: BottomRuleMode) -> String {
            switch mode {
            case .raw:          return bottomLabelRaw
            case .fixed:        return bottomLabelFixed
            case .rawPlusFixed: return bottomLabelRawPlusFixed
            case .rawTimes:     return bottomLabelRawTimes
            }
        }
        
        // Libellés des modes de grande suite (5 dés)
        static let suiteModeSingleFixed = "Valeur unique"
        static let suiteModeSplitFixed  = "Valeurs 1–5 / 2–6"
        static func suiteModeLabel(_ mode: SuiteBigMode) -> String {
            switch mode {
            case .singleFixed: return suiteModeSingleFixed
            case .splitFixed:  return suiteModeSplitFixed
            }
        }

    }
    
    enum Player {
        static let name      = "Nom"
        static let surname      = "Surnom"
        static let email      = "Email"
        static let invite      = "Invité"
    }
}




================================================================================
FILE: YamSheet/Utils/ValidationEngine.swift
================================================================================

//
//  ValidationEngine.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 31/08/2025.
//

import Foundation

/// Validation & affichage des valeurs saisies dans la feuille
enum ValidationEngine {

    // MARK: - Middle (Max/Min)

    /// [5, 30]
    private static func clamp5to30(_ v: Int) -> Int {
        return max(5, min(30, v))
    }

    /// Max dans [5,30], et cohérence vs Min
    /// - strictGreater: true pour le mode "Seuil Somme" (Max > Min), sinon Max >= Min
    static func sanitizeMiddleMax(_ newMax: Int?, currentMin: Int?, strictGreater: Bool) -> Int {
        guard let raw = newMax else { return -1 }          // -1 = vide
        let clamped = clamp5to30(raw)
        if let minv = currentMin, minv >= 0 {
            if strictGreater {
                // Max > Min
                return max(clamped, min(minv + 1, 30))
            } else {
                // Max >= Min
                return max(clamped, minv)
            }
        }
        return clamped
    }

    /// Min dans [5,30], et cohérence vs Max
    /// - strictGreater: true pour Seuil Somme (Min < Max), sinon Min <= Max
    static func sanitizeMiddleMin(_ newMin: Int?, currentMax: Int?, strictGreater: Bool) -> Int {
        guard let raw = newMin else { return -1 }
        let clamped = clamp5to30(raw)
        if let maxv = currentMax, maxv >= 0 {
            if strictGreater {
                // Min < Max
                return min(clamped, max(maxv - 1, 5))
            } else {
                // Min <= Max
                return min(clamped, maxv)
            }
        }
        return clamped
    }

    // MARK: - Bottom (figures)

    /// Sanitize générique pour les figures "basses"
    /// Règles :
    /// - 0 = barré (toujours autorisé)
    /// - raw            : 5...30
    /// - fixed          : 0 ou valeur fixe (définie dans rule.fixedValue)
    /// - rawPlusFixed   : saisie base 5...30 stockée telle quelle (affichage/calcul ajoutent fixedValue)
    /// - rawTimes       : saisie base 5...30 stockée telle quelle (affichage/calcul multiplient par multiplier)
    static func sanitizeBottom(_ newVal: Int?, rule: FigureRule) -> Int {
        guard let v = newVal else { return -1 }            // -1 = vide
        if v == 0 { return 0 }                             // 0 = barré

        switch rule.mode {
        case .raw:
            return clamp5to30(v)

        case .fixed:
            // si non-zéro, on force sur la valeur fixe définie par la notation
            return rule.fixedValue

        case .rawPlusFixed:
            // on stocke la base (5..30), la prime sera gérée en affichage + calcul
            return clamp5to30(v)

        case .rawTimes:
            // on stocke la base (5..30), le facteur sera géré en affichage + calcul
            return clamp5to30(v)
        }
    }

    /// Texte d'affichage "effectif" (ce que la case doit montrer visuellement)
    /// - raw            : v
    /// - fixed          : rule.fixedValue
    /// - rawPlusFixed   : v + rule.fixedValue   (rule.fixedValue = prime)
    /// - rawTimes       : v * rule.multiplier
    static func displayForBottom(stored v: Int, rule: FigureRule) -> String {
        if v < 0 { return "—" }
        if v == 0 { return "0" }

        switch rule.mode {
        case .raw:
            return String(v)
        case .fixed:
            return String(rule.fixedValue)
        case .rawPlusFixed:
            return String(v + rule.fixedValue)
        case .rawTimes:
            return String(v * max(1, rule.multiplier))
        }
    }

    // MARK: - Yams (5 dés identiques) : valeurs autorisées en fonction de la notation
    // Base pour "raw" = somme des 5 dés (5*face)
    static func allowedYamsValues(notation: Notation) -> Set<Int> {
        let rawBases: [Int] = [5, 10, 15, 20, 25, 30]
        let rule = notation.ruleYams

        switch rule.mode {
        case .raw:
            return Set(rawBases)
        case .fixed:
            return Set([rule.fixedValue])
        case .rawPlusFixed:
            return Set(rawBases.map { $0 + rule.fixedValue })
        case .rawTimes:
            return Set(rawBases.map { $0 * max(1, rule.multiplier) })
        }
    }

    /// CHANCE : toute somme 0..30
    static func sanitizeChance(_ newVal: Int?) -> Int {
        guard let v = newVal else { return -1 }
        return max(0, min(30, v)) // 0 accepté pour "barrer"
    }

    /// YAMS : uniquement valeurs autorisées (ou 0 pour barrer)
    static func sanitizeYams(_ newVal: Int?, notation: Notation) -> Int {
        guard let v = newVal else { return -1 }
        if v == 0 { return 0 }
        let allowed = allowedYamsValues(notation: notation)
        return allowed.contains(v) ? v : -1
    }
}



================================================================================
FILE: YamSheet/Utils/Validators.swift
================================================================================

import Foundation

struct Validators {
    /// Allowed values for upper section: [0, 1*face, 2*face, 3*face, 4*face, 5*face]
    static func allowedUpperValues(face: Int) -> [Int] {
        precondition((1...6).contains(face), "Face must be 1...6")
        return [0] + (1...5).map { $0 * face }
    }
}



================================================================================
FILE: YamSheet/Views/EndGameSheet.swift
================================================================================

//
//  EndGameSheet.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/09/2025.
//

import SwiftUI

struct EndGameSheet: View {
    struct Entry: Identifiable {
        var id: UUID { playerID }
        let playerID: UUID
        let name: String
        let score: Int
    }

    let entries: [Entry]  // triées par score desc
    let onClose: () -> Void

    var body: some View {
        VStack(spacing: 16) {
            Text("Partie terminée")
                .font(.title).bold()

            if let winner = entries.first {
                Text("🏆 Vainqueur : \(winner.name) — \(winner.score)")
                    .font(.title3).bold()
                    .padding(.bottom, 8)
            }

            List(entries) { e in
                HStack {
                    Text(e.name)
                    Spacer()
                    Text("\(e.score)").bold()
                }
            }
            .listStyle(.plain)
            .frame(maxHeight: 320)

            Button("Fermer") { onClose() }
                .buttonStyle(.borderedProminent)
        }
        .padding()
        .presentationDetents([.medium, .large])
        .onAppear {
            #if os(iOS)
            UIImpactFeedbackGenerator(style: .soft).impactOccurred()
            #endif
        }
    }
}




================================================================================
FILE: YamSheet/Views/OrderSetupSheet.swift
================================================================================


//
//  OrderSetupSheet.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/09/2025.
//

import SwiftUI

struct OrderSetupSheet<PlayerType: Identifiable>: View {
    @Environment(\.dismiss) private var dismiss
    let players: [PlayerType]
    let idFor: (PlayerType) -> UUID
    let nameFor: (PlayerType) -> String
    let onConfirm: ([UUID]) -> Void

    @State private var order: [PlayerType]

    init(players: [PlayerType],
         idFor: @escaping (PlayerType) -> UUID,
         nameFor: @escaping (PlayerType) -> String,
         onConfirm: @escaping ([UUID]) -> Void)
    {
        self.players = players
        self.idFor = idFor
        self.nameFor = nameFor
        self.onConfirm = onConfirm
        _order = State(initialValue: players)
    }

    var body: some View {
        NavigationStack {
            List {
                ForEach(order) { p in
                    Text(nameFor(p))
                }
                .onMove { from, to in
                    order.move(fromOffsets: from, toOffset: to)
                }
            }
            .navigationTitle("Ordre des joueurs")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Annuler") { dismiss() }
                }
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Mélanger") { order.shuffle() }
                }
                ToolbarItem(placement: .primaryAction) {
                    Button("Valider") {
                        onConfirm(order.map(idFor))
                        dismiss()
                    }
                }
                ToolbarItem(placement: .bottomBar) {
                    EditButton()
                }
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/TurnHeaderView.swift
================================================================================

//
//  TurnHeaderView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/09/2025.
//

import SwiftUI

struct TurnHeaderView<PlayerType: Identifiable>: View {
    let players: [PlayerType]
    let idFor: (PlayerType) -> UUID
    let nameFor: (PlayerType) -> String
    let activePlayerID: UUID?
    let onTapPlayer: (PlayerType) -> Void
    let onPause: () -> Void
    let onNext: () -> Void

    var body: some View {
        VStack(spacing: 8) {
            HStack {
                Text(activeTitle)
                    .font(.headline)
                Spacer()
                Button("Mettre en pause", action: onPause)
            }
            .padding(.bottom, 4)

            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(players) { p in
                        let isActive = (idFor(p) == activePlayerID)
                        Text(nameFor(p))
                            .font(isActive ? .headline.bold() : .body)
                            .padding(.horizontal, 10).padding(.vertical, 6)
                            .background(isActive ? Color.yellow.opacity(0.3) : Color.gray.opacity(0.12))
                            .clipShape(Capsule())
                            .onTapGesture { onTapPlayer(p) }
                    }
                }
            }

            Button {
                onNext()
            } label: {
                Text("Joueur suivant")
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
        }
    }

    private var activeTitle: String {
        guard let id = activePlayerID,
              let p = players.first(where: { idFor($0) == id }) else { return "Au tour de —" }
        return "Au tour de \(nameFor(p))"
    }
}




================================================================================
FILE: YamSheet/Views/components/NumericRow.swift
================================================================================

//
//  NumericRow.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 14/09/2025.
//
import SwiftUI

/// Ligne de saisie numérique (score) avec affichage optionnel d'une valeur effective (ex: bonus).
struct NumericRow: View {

    struct Config {
        var label: String = ""                          // non utilisé ici (le label est géré par la grille)
        var value: Binding<Int>                         // -1 = vide ; >=0 = valeur saisie
        var isLocked: Bool = false
        var isActive: Bool = true                       // joueur actif => style différent
        var validator: ((Int?) -> Int)? = nil           // VALIDATION AU COMMIT uniquement
        var displayMap: ((Int) -> String)? = nil        // transforme la valeur stockée en valeur “effective”
        var valueFont: Font? = nil                      // font de la valeur brute (badge)
        var effectiveFont: Font? = nil                  // font de la valeur centrale (effective)
        var contentPadding: CGFloat = 8                 // padding interne dynamique
        var allowedRange: ClosedRange<Int> = 5...30
        var allowZero: Bool = false
        var onInvalidInput: ((Int) -> Void)? = nil
    }

    private let cfg: Config

    // Etat local d'édition (buffer texte). On ne pousse vers cfg.value QU'AU COMMIT.
    @State private var text: String = ""
    @FocusState private var isFocused: Bool

    init(_ cfg: Config) { self.cfg = cfg }

    var body: some View {
        ZStack {
            // 1) Zone éditable : TextField visible en édition (curseur centré), quasi invisible sinon
            TextField(
                UIStrings.Common.dash,
                text: $text
            )
            .focused($isFocused)
            .keyboardType(.numberPad)
            .disableAutocorrection(true)
            .textInputAutocapitalization(.never)
            .submitLabel(.done)
            .multilineTextAlignment(.center)            // curseur & saisie centrés
            .opacity(isFocused ? 1.0 : 0.001)           // hors focus on masque le texte natif
            .padding(cfg.contentPadding)
            .frame(maxWidth: .infinity, minHeight: 36)  // même hauteur que les Picker
            .background(backgroundColor)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(Color.accentColor.opacity(isFocused ? 0.35 : 0.0), lineWidth: 1)
            )
            .onSubmit { commit() }
            .onChange(of: isFocused) { was, now in
                if was && !now { commit() }             // commit quand on quitte la case
            }
            .onAppear { syncFromBinding() }
            .onChange(of: cfg.value.wrappedValue) { _, _ in
                if !isFocused { syncFromBinding() }     // resync si modif externe
            }
            .onChange(of: text) { _, newText in
                // Laisser taper librement, mais filtrer aux chiffres
                let filtered = newText.filter { $0.isNumber }
                if filtered != newText { text = filtered }
            }

            // 2) Calculs d'affichage (raw/effective)
            let raw = cfg.value.wrappedValue
            let rawText = (raw >= 0) ? String(raw) : ""
            let effText: String? = {
                guard raw >= 0, let map = cfg.displayMap else { return nil }
                let eff = map(raw)
                return eff != rawText ? eff : nil
            }()

            // 3) Texte central (affiché uniquement hors édition)
            if !isFocused {
                Text(effText ?? (rawText.isEmpty ? "—" : rawText))
                    .font(cfg.effectiveFont)            // 👈 utilise la police fournie
                    .foregroundColor(.primary)
                    .frame(maxWidth: .infinity, alignment: .center)
                    // réserve de place pour le badge à droite si effText
                    .padding(.horizontal, effText != nil ? max(16, cfg.contentPadding * 2) : cfg.contentPadding)
                    .allowsHitTesting(false)
            }

            // 4) Badge à droite : valeur brute seulement quand non focus ET différente de l’effective
            if !isFocused, let _ = effText, !rawText.isEmpty {
                Text(rawText)
                    .font(cfg.valueFont)                // 👈 utilise la police fournie
                    .foregroundColor(.secondary)
                    .padding(.horizontal, max(4, cfg.contentPadding * 0.75))
                    .padding(.vertical, max(2, cfg.contentPadding * 0.25))
                    .background(Color.black.opacity(0.06))
                    .clipShape(Capsule())
                    .frame(maxWidth: .infinity, alignment: .trailing)
                    .padding(.trailing, max(4, cfg.contentPadding * 0.75))
                    .lineLimit(1)
                    .minimumScaleFactor(0.6)
                    .allowsHitTesting(false)
            }
        }
        .contentShape(Rectangle())
        .onTapGesture { isFocused = true }
        .disabled(cfg.isLocked || !cfg.isActive)
        .animation(.easeInOut(duration: 0.12), value: isFocused)
    }

    // MARK: - Commit / Sync
    private func commit() {
        // Validation différée au commit
        let previous = cfg.value.wrappedValue
        let intVal = Int(text)
        var validated = cfg.validator?(intVal) ?? (intVal ?? -1)

        // Si l'utilisateur saisit une valeur > 0 mais que le validator la rejette (== -1),
        // on n'auto-corrige pas : on notifie et on restaure la valeur précédente.
        if let raw = intVal, raw > 0, cfg.validator != nil, validated == -1 {
            cfg.onInvalidInput?(raw)
            // Restaure la valeur précédente sans modification
            cfg.value.wrappedValue = previous
            syncFromBinding()
            return
        }

        // Autoriser explicitement 0 (barré) si demandé par la config
        if validated == 0, cfg.allowZero {
            cfg.value.wrappedValue = 0
            syncFromBinding()
            return
        }

        // Clamp final via allowedRange (uniquement pour les valeurs strictement positives)
        if validated > 0 {
            if validated < cfg.allowedRange.lowerBound { validated = cfg.allowedRange.lowerBound }
            if validated > cfg.allowedRange.upperBound { validated = cfg.allowedRange.upperBound }
        }

        cfg.value.wrappedValue = validated
        syncFromBinding() // refléter la valeur stockée
    }

    private func syncFromBinding() {
        let v = cfg.value.wrappedValue
        text = (v >= 0) ? String(v) : ""
    }

    // MARK: - Styling
    private var backgroundColor: Color {
        let isOpen = (cfg.value.wrappedValue == -1)
        if cfg.isActive {
            return isOpen ? Color.blue.opacity(0.12) : Color.green.opacity(0.12)
        } else {
            return Color.gray.opacity(0.08)
        }
    }
}



================================================================================
FILE: YamSheet/Views/components/PickerRow.swift
================================================================================

//
//  PickerRow.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 14/09/2025.
//

import SwiftUI

public struct PickerRow: View {
    let label: String
    let values: [Int]
    @Binding var selection: Int
    let valueToText: (Int) -> String

    public init(label: String, values: [Int], selection: Binding<Int>, valueToText: @escaping (Int) -> String) {
        self.label = label
        self.values = values
        self._selection = selection
        self.valueToText = valueToText
    }

    public var body: some View {
        HStack {
            Text(label).frame(width: 110, alignment: .leading)
            Menu {
                Picker("Valeur", selection: $selection) {
                    ForEach(values, id: \.self) { v in
                        Text(valueToText(v)).tag(v)
                    }
                }
            } label: {
                Text(valueToText(selection))
                    .frame(maxWidth: .infinity)
                    .padding(8)
                    .background(Color.gray.opacity(0.08))
                    .clipShape(RoundedRectangle(cornerRadius: 8))
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/components/PlayerFormView.swift
================================================================================

//
//  PlayerFormView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/09/2025.
//

import SwiftUI
import PhotosUI

struct PlayerFormView: View {
    struct Draft {
        var name: String = ""
        var nickname: String = ""
        var email: String = ""
        var favoriteEmoji: String = ""
        var preferredColor: Color = .blue
        var isGuest: Bool = false
        var avatarImageData: Data?
    }

    @Binding var draft: Draft
    var isEditing: Bool = false
    var onValidate: ((Draft) -> Void)?
    var onCancel: (() -> Void)?

    @State private var photoItem: PhotosPickerItem?
    @FocusState private var focusedField: Field?
    enum Field { case name, nickname, email, emoji }

    var body: some View {
        Form {
            Section("Identité") {
                HStack {
                    AvatarView(data: draft.avatarImageData)
                    PhotosPicker(selection: $photoItem, matching: .images, photoLibrary: .shared()) {
                        Text("Choisir une photo").font(.callout)
                    }
                    .onChange(of: photoItem) { _, newValue in
                        Task {
                            if let data = try? await newValue?.loadTransferable(type: Data.self) {
                                draft.avatarImageData = data
                            }
                        }
                    }
                }

                TextField("Nom (obligatoire)", text: $draft.name)
                    .textContentType(.name)
                    .focused($focusedField, equals: .name)

                TextField("Surnom", text: $draft.nickname)
                    .textContentType(.nickname)
                    .focused($focusedField, equals: .nickname)

                TextField("Email (facultatif)", text: $draft.email)
                    .keyboardType(.emailAddress)
                    .textContentType(.emailAddress)
                    .autocapitalization(.none)
                    .disableAutocorrection(true)
                    .focused($focusedField, equals: .email)

                Toggle("Invité", isOn: $draft.isGuest)
            }

            Section("Préférences") {
                TextField("Emoji favori (facultatif)", text: $draft.favoriteEmoji)
                    .focused($focusedField, equals: .emoji)

                ColorPicker("Couleur", selection: $draft.preferredColor, supportsOpacity: false)
            }

            Section {
                Button(isEditing ? "Enregistrer" : "Créer") {
                    onValidate?(draft)
                }
                .buttonStyle(.borderedProminent)
                .disabled(draft.name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)

                if onCancel != nil {
                    Button("Annuler", role: .cancel) { onCancel?() }
                }
            }
        }
    }
}

private struct AvatarView: View {
    var data: Data?
    var body: some View {
        Group {
            if let data, let img = UIImage(data: data) {
                Image(uiImage: img)
                    .resizable().scaledToFill()
            } else {
                Image(systemName: "person.crop.circle.fill")
                    .resizable().scaledToFit()
                    .symbolRenderingMode(.hierarchical)
                    .foregroundStyle(.secondary)
                    .padding(10)
            }
        }
        .frame(width: 64, height: 64)
        .clipShape(Circle())
        .overlay {
            Circle().stroke(.quaternary, lineWidth: 1)
        }
    }
}



================================================================================
FILE: YamSheet/Views/games/ConfettiView.swift
================================================================================

//
//  ConfettiView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 06/09/2025.
//

import SwiftUI

struct ConfettiView: UIViewRepresentable {
    func makeUIView(context: Context) -> UIView {
        let v = UIView()
        DispatchQueue.main.async {
            let layer = CAEmitterLayer()
            layer.emitterPosition = CGPoint(x: v.bounds.midX, y: -10)
            layer.emitterShape = .line
            layer.emitterSize = CGSize(width: v.bounds.width, height: 1)

            func cell(_ color: UIColor, _ img: UIImage?) -> CAEmitterCell {
                let c = CAEmitterCell()
                c.birthRate = 8
                c.lifetime = 6
                c.velocity = 180
                c.velocityRange = 80
                c.emissionLongitude = .pi
                c.emissionRange = .pi / 6
                c.spin = 3.5
                c.spinRange = 2.0
                c.scale = 0.6
                c.scaleRange = 0.3
                c.color = color.cgColor
                c.contents = (img ?? UIImage(systemName: "circle.fill"))?.cgImage
                return c
            }

            let colors: [UIColor] = [.systemPink, .systemYellow, .systemGreen, .systemBlue, .systemPurple, .systemOrange]
            let imgs: [UIImage?] = [UIImage(systemName: "suit.heart.fill"),
                                    UIImage(systemName: "suit.club.fill"),
                                    UIImage(systemName: "suit.diamond.fill"),
                                    UIImage(systemName: "suit.spade.fill")]
            layer.emitterCells = (0..<14).map { i in
                cell(colors[i % colors.count], imgs[i % imgs.count])
            }

            v.layer.addSublayer(layer)
            // Arrêt automatique après 2,5s
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.5) {
                layer.birthRate = 0
            }
        }
        return v
    }
    func updateUIView(_ uiView: UIView, context: Context) {}
}



================================================================================
FILE: YamSheet/Views/games/EndGameCongratsView.swift
================================================================================

//
//  EndGameCongratsView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 06/09/2025.
//

import SwiftUI

struct EndGameCongratsView: View {
    struct Entry: Identifiable {
        let id = UUID()
        let name: String
        let score: Int
    }

    let gameName: String?
    let entries: [Entry]
    let dismiss: () -> Void

    // Si dossier BLEU "Resources", laisse "Resources". Si dossier JAUNE (Group), mets nil.
    private let lottieSubdir: String? = "Resources"

    // Auto-détection de tous les .json dans le bundle (racine + Resources)
    private var animationNames: [String] {
        let inRes  = Bundle.main.paths(forResourcesOfType: "json", inDirectory: "Resources")
        let inRoot = Bundle.main.paths(forResourcesOfType: "json", inDirectory: nil)
        let all = (inRes + inRoot)
            .map { URL(fileURLWithPath: $0).deletingPathExtension().lastPathComponent }
            .reduce(into: [String]()) { acc, name in if !acc.contains(name) { acc.append(name) } }
            .sorted()
        #if DEBUG
        print("[EndGameCongrats] JSON détectés:", all)
        #endif
        return all
    }

    private var winnerName: String { entries.first?.name ?? "—" }

    var body: some View {
        // === CONTENU PRINCIPAL (définit le layout du sheet) ===
        let content = VStack(spacing: 16) {
            Text("Partie terminée")
                .font(.title3.bold())

            if let n = gameName, !n.isEmpty {
                Text(n)
                    .font(.footnote)
                    .foregroundStyle(.secondary)
            }

            HStack(spacing: 8) {
                Image(systemName: "trophy.fill").imageScale(.large)
                Text("Bravo \(winnerName) !")
                    .font(.title2.weight(.semibold))
            }
            .foregroundStyle(.orange)

            // Tableau "classique"
            VStack(alignment: .leading, spacing: 10) {
                ForEach(Array(entries.enumerated()), id: \.offset) { idx, e in
                    HStack {
                        Text("\(idx + 1). \(e.name)")
                        Spacer()
                        Text("\(e.score)").fontWeight(.semibold)
                    }
                    .font(idx == 0 ? .headline : .body)
                }
            }
            .padding()
            .background(Color(.secondarySystemBackground))
            .clipShape(RoundedRectangle(cornerRadius: 14))
            .shadow(radius: 2)

            Button(action: dismiss) {
                Text("OK").frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
        }
        .padding(20)

        // === IMPORTANT : LOTTIE EN OVERLAY (n’affecte PAS la taille) ===
        return content
            // (Optionnel) Dim léger pour mieux faire ressortir l’anim :
            //.overlay(alignment: .center) {
            //    Color.black.opacity(0.12).allowsHitTesting(false).clipped()
            //}
            .overlay(alignment: .center) {
                // L’overlay reçoit exactement la même taille que `content`
                LottieRandomCelebrationView(
                    names: animationNames,
                    loopOnce: false,
                    speed: 0.80,
                    subdirectory: lottieSubdir
                )
                .opacity(0.20)               // plein pot; ajuste si besoin
                .blendMode(.normal)       // tu peux tester .screen / .plusLighter / .overlay
                .allowsHitTesting(false)    // ne bloque pas le bouton OK
                .clipped()                  // ne déborde pas du content
            }
            .presentationDetents([.medium])
            .presentationDragIndicator(.visible)
            .onAppear { UINotificationFeedbackGenerator().notificationOccurred(.success) }
    }
}



================================================================================
FILE: YamSheet/Views/games/GameDetail/GDV.Header.swift
================================================================================

//
//  GDV.Header.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 14/09/2025.
//
import SwiftUI
import SwiftData   // ✅ ajoute ceci


struct GDV_Header: View {
    @Environment(\.modelContext) private var modelContext
    @Query private var allPlayers: [Player]

    private func colorForPlayerID(_ id: UUID?) -> Color {
        guard let id, let p = allPlayers.first(where: { $0.id == id }) else { return .accentColor }
        return p.color
    }

    private func colorForColumnIndex(_ idx: Int, using columnPlayerIDs: [UUID]) -> Color {
        guard idx >= 0 && idx < columnPlayerIDs.count else { return .accentColor }
        return colorForPlayerID(columnPlayerIDs[idx])
    }
    
    
    private var activeColor: Color {
        // Si le header a accès à `game.activePlayerID`
        if let g = (Mirror(reflecting: self).children.first { $0.label == "game" }?.value as? Game) {
            return colorForPlayerID(g.activePlayerID)
        }
        // Sinon, si le header expose directement activePlayerID
        if let apid = (Mirror(reflecting: self).children.first { $0.label == "activePlayerID" }?.value as? UUID) {
            return colorForPlayerID(apid)
        }
        return .accentColor
    }
    
    
    let title: String
    let subtitle: String?

    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(title).font(.title3.weight(.semibold))
                if let subtitle {
                    Text(subtitle).font(.footnote).foregroundStyle(.secondary)
                }
            }
            Spacer()
        }
        .padding(.vertical, 4)
    }
}



================================================================================
FILE: YamSheet/Views/games/GameDetail/GDV.Helpers.swift
================================================================================

//
//  GDV.Helpers.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 14/09/2025.
//

import Foundation

enum GDV_Helpers {
    static func dashOr(_ value: Int) -> String { value >= 0 ? String(value) : "—" }
    // On déplacera ici ultérieurement les helpers purs (formatage, validations, etc.)

        // Affichage en cellule (numérique ou "—")
        static func displaySuiteValue(_ v: Int) -> String {
            return v == -1 ? UIStrings.Common.dash : String(v)
        }

        static func displayPetiteSuiteValue(_ v: Int) -> String {
            return v == -1 ? UIStrings.Common.dash : String(v)
        }

        // Optionnel : déplacer aussi la logique "allowed values"
        static func suiteAllowedValues(notation: Notation) -> [Int] {
            switch notation.suiteBigMode {
            case .singleFixed:
                return [0, notation.suiteBigFixed]
            case .splitFixed:
                return [0, notation.suiteBigFixed1to5, notation.suiteBigFixed2to6]
            @unknown default:
                return [0, 15, 20]
            }
        }

        static func petiteSuiteAllowedValues(notation: Notation) -> [Int] {
            return [0, notation.rulePetiteSuite.fixedValue]
        }

        // Libellés du MENU du picker (pas l’affichage dans la cellule)
        static func suiteMenuLabel(_ v: Int, notation: Notation) -> String {
            if v == -1 { return UIStrings.Common.dash }
            if v == 0  { return "0" }
            switch notation.suiteBigMode {
            case .singleFixed:
                return String(v)
            case .splitFixed:
                if v == notation.suiteBigFixed1to5 { return "1 à 5" }
                if v == notation.suiteBigFixed2to6 { return "2 à 6" }
                return String(v)
            @unknown default:
                return String(v)
            }
        }

        static func petiteSuiteMenuLabel(_ v: Int, notation: Notation) -> String {
            if v == -1 { return UIStrings.Common.dash }
            if v == 0  { return "0" }
            return UIStrings.Game.petiteSuite
        }
    
    
    
}



================================================================================
FILE: YamSheet/Views/games/GameDetail/GDV.PlayerChips.swift
================================================================================

//
//  GDV.PlayerChips.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 14/09/2025.
//

import SwiftUI

struct GDV_PlayerChips: View {
    let players: [String]
    let activeIndex: Int?

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 8) {
                ForEach(Array(players.enumerated()), id: \.offset) { idx, name in
                    Text(name)
                        .font(.footnote.weight(.semibold))
                        .padding(.horizontal, 10).padding(.vertical, 6)
                        .background((idx == activeIndex) ? Color.yellow.opacity(0.28) : Color.gray.opacity(0.12))
                        .clipShape(Capsule())
                }
            }
            .padding(.vertical, 4)
        }
    }
}



================================================================================
FILE: YamSheet/Views/games/GameDetail/GDV.ScoreInputs.swift
================================================================================

//
//  GDV.ScoreInputs.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 14/09/2025.
//

import SwiftUI

struct GDV_ScoreInputs: View {
    // À câbler lors de l’étape 3 (on injectera les closures/validators)
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Inputs").font(.headline)
            Text("— à connecter au prochain passage —").font(.footnote).foregroundStyle(.secondary)
        }
    }
}



================================================================================
FILE: YamSheet/Views/games/GameDetail/GDV.ScoreTotals.swift
================================================================================

//
//  GDV.ScoreTotals.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 14/09/2025.
//

import SwiftUI

struct GDV_ScoreTotals: View {
    let totalText: (Int) -> String
    let playerCount: Int

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Totaux").font(.headline)
            HStack {
                Text("Total").frame(width: 110, alignment: .leading)
                ForEach(0..<playerCount, id: \.self) { idx in
                    Text(totalText(idx))
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding(8)
                        .background(Color.gray.opacity(0.08))
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                }
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/games/GameDetailView.swift
================================================================================

//
//  GameDetailView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 06/09/2025.
//

import SwiftUI
import SwiftData

struct GameDetailView: View {
    // Accès aux joueurs pour récupérer leur couleur
    @Query private var allPlayers: [Player]

    // Couleur pour un playerID
    private func colorForPlayerID(_ id: UUID?) -> Color {
        guard let id, let p = allPlayers.first(where: { $0.id == id }) else { return .accentColor }
        return p.color
    }

    // Si tu as un tableau d’IDs affichés (ex. displayPlayerIDs), utilitaire par index
    private func colorForColumnIndex(_ idx: Int, in ids: [UUID]) -> Color {
        guard idx >= 0 && idx < ids.count else { return .accentColor }
        return colorForPlayerID(ids[idx])
    }
    
    
    // MARK: - Env & Model
    @Environment(\.modelContext) private var context
    @Environment(\.dismiss) private var dismiss
    @Environment(\.scenePhase) private var scenePhase

  
    @Bindable var game: Game

    // MARK: - UI State
    @State private var showTip = false
    @State private var tipText = ""
    @State private var showRevokeYams = false
    @State private var revokePlayerIdx: Int? = nil
    @State private var showEndGameSheet = false
    @State private var showOrderSheet = false
    @State private var alertMessage = ""
    @State private var showAlert = false
    @State private var showCongrats = false
    @State private var endGameEntries: [EndGameCongratsView.Entry] = []

    // MARK: - Columns (multi-colonnes plus tard)
    private var scoreColumnIndex: Int { 0 }

    // MARK: - Layout
    private let outerHPadding: CGFloat = 32    // .padding(.horizontal) 16+16
    private let labelColumnWidth: CGFloat = 110
    private let perColumnOuterPad: CGFloat = 4 // padding(.horizontal,2) visuel sur colonnes
    private let safetyGutter: CGFloat = 8      // marge anti-rognage

    /// IDs des joueurs à afficher (actif d’abord)
    private var displayPlayerIDs: [UUID] {
        var seen = Set<UUID>(), ids: [UUID] = []
        if let active = game.activePlayerID,
           game.scorecards.contains(where: { $0.playerID == active }) {
            ids.append(active); seen.insert(active)
        }
        for id in game.turnOrder where !seen.contains(id) {
            if game.scorecards.contains(where: { $0.playerID == id }) { ids.append(id); seen.insert(id) }
        }
        for sc in game.scorecards where !seen.contains(sc.playerID) {
            ids.append(sc.playerID); seen.insert(sc.playerID)
        }
        return ids
    }

    /// Largeur mini d'une colonne joueur, calculée pour que 1–4 joueurs tiennent sans scroll.
    /// Bornée 50..64 pour conserver la lisibilité.
    private var minCellWidth: CGFloat {
        let n = max(1, min(4, displayPlayerIDs.count)) // calcule pour 1..4
        let screenW = UIScreen.main.bounds.width
        let available = max(0,
            screenW
            - outerHPadding
            - labelColumnWidth
            - safetyGutter
            - CGFloat(n) * perColumnOuterPad
        )
        let perCol = floor(available / CGFloat(n))
        return max(50, min(64, perCol))
    }

    /// Padding interne dynamique (on serre à 4 joueurs)
    private var cellPadding: CGFloat {
        switch displayPlayerIDs.count {
        case 0,1: return 8
        case 2:   return 7
        case 3:   return 5
        case 4:   return 2
        default:  return 8
        }
    }

    /// Police proportionnelle à la largeur de colonne
    private var cellFont: Font {
        let sz = max(13, min(17, minCellWidth * 0.32))
        return .system(size: sz)
    }
    private var badgeFont: Font {
        let sz = max(10, min(12, minCellWidth * 0.28))
        return .system(size: sz)
    }
    
    // Hauteurs normalisées pour aligner labels (gauche) et cellules (droite)
    private let cellRowHeight: CGFloat = 36      // chaque cellule / total
    private let headerRowHeight: CGFloat = 28    // ligne "Section haute / milieu / basse"
    private let namesHeaderHeight: CGFloat = 26  // bandeau des noms (chips de colonnes)
    private let namesHeaderBottom: CGFloat = 2   // marge sous ce bandeau


    // MARK: - Participants & Order
    private var participants: [Player] {
        let byId = Dictionary(uniqueKeysWithValues: allPlayers.map { ($0.id, $0) })
        return game.participantIDs.compactMap { byId[$0] }
    }

    private var orderedPlayers: [Player] {
        let byId = Dictionary(uniqueKeysWithValues: participants.map { ($0.id, $0) })
        let inOrder = game.turnOrder.compactMap { byId[$0] }
        return inOrder.isEmpty ? participants : inOrder
    }

    private var activeScorecardIndex: Int? {
        guard let pid = game.activePlayerID else { return nil }
        return game.scorecards.firstIndex(where: { $0.playerID == pid })
    }

    /// index de scorecard par id joueur
    private var scorecardIndexByPlayerID: [UUID: Int] {
        Dictionary(uniqueKeysWithValues: game.scorecards.enumerated().map { ($0.element.playerID, $0.offset) })
    }

    // “Au tour de …”
    private var activePlayerName: String {
        if let pid = game.activePlayerID,
           let p = allPlayers.first(where: { $0.id == pid }) {
            return p.nickname
        }
        return "—"
    }

    // MARK: - Tour par tour
    private func isCellEnabled(for playerID: UUID) -> Bool {
        guard game.statusOrDefault == .inProgress else { return false }
        return game.activePlayerID == playerID
    }

    /// nb de cases remplies (toutes sections)
    private func currentFillableCount(for playerID: UUID) -> Int {
        guard let sc = game.scorecards.first(where: { $0.playerID == playerID }) else { return 0 }
        let i = scoreColumnIndex
        func f(_ a: [Int]) -> Int { (i < a.count && a[i] >= 0) ? 1 : 0 }
        var c = 0
        // haute
        c += f(sc.ones); c += f(sc.twos); c += f(sc.threes)
        c += f(sc.fours); c += f(sc.fives); c += f(sc.sixes)
        // milieu
        c += f(sc.maxVals); c += f(sc.minVals)
        // basse
        c += f(sc.brelan)
        if game.enableChance { c += f(sc.chance) }
        c += f(sc.full)
        c += f(sc.suite)
        if game.enableSmallStraight { c += f(sc.petiteSuite) }
        c += f(sc.carre)
        c += f(sc.yams)
        return c
    }

    private func ensureTurnSnapshotInitialized() {
        if let pid = game.activePlayerID {
            let count = currentFillableCount(for: pid)
            game.beginTurnSnapshot(for: pid, fillableCount: count)
        }
    }

    private var canShowNextButton: Bool {
        guard game.statusOrDefault == .inProgress, let pid = game.activePlayerID else { return false }
        let now = currentFillableCount(for: pid)
        let start = game.lastFilledCountByPlayer[pid] ?? now
        return (now - start) == 1
    }

    private var requiredCellsCountPerPlayer: Int {
        var n = 13
        if game.enableChance { n += 1 }
        if game.enableSmallStraight { n += 1 }
        return n
    }

    private var canChangePlayerByTap: Bool {
        guard game.statusOrDefault == .inProgress, let pid = game.activePlayerID else { return false }
        let now = currentFillableCount(for: pid)
        let start = game.lastFilledCountByPlayer[pid] ?? now
        return (now - start) >= 1
    }

    private func requiredFilledCount(for sc: Scorecard) -> Int {
        let i = scoreColumnIndex
        func f(_ a: [Int]) -> Int { (i < a.count && a[i] >= 0) ? 1 : 0 }
        var c = 0
        c += f(sc.ones); c += f(sc.twos); c += f(sc.threes)
        c += f(sc.fours); c += f(sc.fives); c += f(sc.sixes)
        c += f(sc.maxVals); c += f(sc.minVals)
        c += f(sc.brelan)
        if game.enableChance { c += f(sc.chance) }
        c += f(sc.full)
        c += f(sc.suite)
        if game.enableSmallStraight { c += f(sc.petiteSuite) }
        c += f(sc.carre)
        c += f(sc.yams)
        return c
    }

    private func isGameCompletedNow() -> Bool {
        game.scorecards.allSatisfy { requiredFilledCount(for: $0) >= requiredCellsCountPerPlayer }
    }

    // MARK: - Actions
    private func onNextPlayerTapped() {
        hideKeyboard() // commit NumericRow si focus

        guard let pid = game.activePlayerID else { return }
        let countNow = currentFillableCount(for: pid)
        game.beginTurnSnapshot(for: pid, fillableCount: countNow)
        guard game.canEndTurn(for: pid, fillableCount: countNow) else {
            alertMessage = "Ce joueur doit remplir exactement 1 case avant de passer son tour."
            showAlert = true
            return
        }
        lockExtraYamsForActiveIfNeeded()
        game.endTurnCommit(for: pid, fillableCount: countNow)
        game.advanceToNextPlayer()

        if isGameCompletedNow() {
            game.statusOrDefault = .completed
            game.endedAt = Date()
            let ranking: [(String, Int)] = orderedPlayers
                .map { ($0.nickname, totalScore(for: $0.id)) }
                .sorted { $0.1 > $1.1 }

            if scenePhase != .active {
                NotificationManager.postEndGame(
                    winnerName: ranking.first?.0 ?? "—",
                    gameName: game.name,
                    rankings: ranking
                )
            } else {
                endGameEntries = ranking.map { .init(name: $0.0, score: $0.1) }
                showCongrats = true
            }
        }
        try? context.save()
    }

    private func pauseAndGoHome() {
        let didAdvance = endTurnIfExactlyOneFilledAndAdvance()
        markAutoAdvanceOnPause(didAdvance)
        game.statusOrDefault = .paused
        try? context.save()
        NotificationCenter.default.post(name: .closeToGamesList, object: game.id)
        DispatchQueue.main.async { dismiss() }
    }

    private func finishNowAndGoHome() {
        game.statusOrDefault = .completed
        game.endedAt = Date()
        try? context.save()
        NotificationCenter.default.post(name: .closeToGamesList, object: game.id)
        DispatchQueue.main.async { dismiss() }
    }

    private func endTurnIfExactlyOneFilledAndAdvance() -> Bool {
        guard game.statusOrDefault == .inProgress, let pid = game.activePlayerID else { return false }
        let now = currentFillableCount(for: pid)
        let start = game.lastFilledCountByPlayer[pid] ?? now
        guard (now - start) == 1 else { return false }

        lockExtraYamsForActiveIfNeeded()
        game.endTurnCommit(for: pid, fillableCount: now)
        game.advanceToNextPlayer()
        ensureTurnSnapshotInitialized()
        return true
    }

    private func markAutoAdvanceOnPause(_ didAdvance: Bool) {
        let key = "autoAdvanceOnPause.\(game.id.uuidString)"
        UserDefaults.standard.set(didAdvance, forKey: key)
    }

    private func consumeAutoAdvanceOnPauseFlag() -> Bool {
        let key = "autoAdvanceOnPause.\(game.id.uuidString)"
        let did = UserDefaults.standard.bool(forKey: key)
        UserDefaults.standard.removeObject(forKey: key)
        return did
    }

    // MARK: - Apparence cellules
    private func isActiveIndex(_ idx: Int) -> Bool {
        guard let pid = game.activePlayerID else { return false }
        return game.scorecards[idx].playerID == pid
    }

    private func cellBackground(col: Int, isOpen: Bool) -> Color {
        if isActiveIndex(col) {
            return isOpen ? Color.blue.opacity(0.12) : Color.green.opacity(0.12)
        } else {
            return Color.gray.opacity(0.08)
        }
    }

    // MARK: - Manquants utiles
    private func finishGameAndGoHome() {
        game.statusOrDefault = .completed
        game.endedAt = Date()
        try? context.save()
        NotificationCenter.default.post(name: .closeToGamesList, object: game.id)
        showCongrats = false
        DispatchQueue.main.async { dismiss() }
    }

    private func autoPauseIfNeeded(reason: String) {
        guard game.statusOrDefault == .inProgress else { return }
        let didAdvance = endTurnIfExactlyOneFilledAndAdvance()
        markAutoAdvanceOnPause(didAdvance)
        game.statusOrDefault = .paused
        try? context.save()
        #if DEBUG
        print("[GameDetailView] Auto-pause (\(reason)) • didAdvance=\(didAdvance)")
        #endif
    }

    private func revokeExtraYams(for playerIdx: Int) {
        var arr = game.scorecards[playerIdx].extraYamsAwarded
        if scoreColumnIndex < arr.count && scoreColumnIndex >= 0 {
            arr[scoreColumnIndex] = false
            game.scorecards[playerIdx].extraYamsAwarded = arr
            try? context.save()
        }
    }

    private func setActivePlayer(_ pid: UUID) {
        guard game.statusOrDefault == .inProgress else { return }
        guard let current = game.activePlayerID else { return }
        if current == pid { return }

        let now = currentFillableCount(for: current)
        let start = game.lastFilledCountByPlayer[current] ?? now
        guard (now - start) >= 1 else {
            UINotificationFeedbackGenerator().notificationOccurred(.warning)
            alertMessage = "Remplis au moins une case avant de changer de joueur."
            showAlert = true
            return
        }
        game.jumpTo(playerID: pid)
        ensureTurnSnapshotInitialized()
    }
    
    // Verrouille la prime Yams du joueur actif au moment où le tour est validé
    private func lockExtraYamsForActiveIfNeeded() {
        guard let idx = activeScorecardIndex else { return }
        let sc = game.scorecards[idx]
        let alreadyAwarded = sc.extraYamsAwarded.indices.contains(scoreColumnIndex)
                           && sc.extraYamsAwarded[scoreColumnIndex]
        let alreadyLocked  = sc.isLocked(col: scoreColumnIndex, key: "ExtraYamsBonus")
        if alreadyAwarded && !alreadyLocked {
            game.scorecards[idx].setLocked(true, col: scoreColumnIndex, key: "ExtraYamsBonus")
        }
    }
    
    

    // MARK: - Header moderne
    private var activeIndexForChips: Int? {
        guard let aid = game.activePlayerID else { return nil }
        return orderedPlayers.firstIndex(where: { $0.id == aid })
    }

    private var statusSubtitle: String? {
        switch game.statusOrDefault {
        case .inProgress: return "À \(activePlayerName) de jouer"
        case .paused:     return "Partie en pause"
        case .completed:  return "Partie terminée"
        }
    }

    @ViewBuilder
    private func modernHeader() -> some View {
        GDV_Header(title: game.name, subtitle: statusSubtitle)
       /* GDV_PlayerChips(
            players: orderedPlayers.map { $0.nickname },
            activeIndex: activeIndexForChips
        )*/
        .frame(maxWidth: .infinity, alignment: .leading)
    }


    // MARK: - Body
    var body: some View {
        ScrollView {
            LazyVStack(alignment: .leading, spacing: 12) {
                modernHeader()
                grid()
            }
            .padding(.horizontal)
        }
        .sheet(isPresented: $showEndGameSheet) {
            let entries: [EndGameSheet.Entry] = orderedPlayers
                .map { p in EndGameSheet.Entry(playerID: p.id, name: p.nickname, score: totalScore(for: p.id)) }
                .sorted { $0.score > $1.score }
            EndGameSheet(entries: entries) { showEndGameSheet = false }
        }
        .sheet(isPresented: $showOrderSheet) {
            OrderSetupSheet(
                players: participants,
                idFor: { $0.id },
                nameFor: { $0.nickname },
                onConfirm: { ids in
                    game.setTurnOrder(ids); try? context.save()
                }
            )
        }
        .sheet(isPresented: $showCongrats) {
            EndGameCongratsView(
                gameName: game.name,
                entries: endGameEntries,
                dismiss: { finishGameAndGoHome() }
            )
        }
        .onAppear {
            NotificationManager.requestAuthorizationIfNeeded()
            if game.turnOrder.isEmpty && orderedPlayers.count >= 2 { showOrderSheet = true }
            ensureTurnSnapshotInitialized()

            if game.statusOrDefault == .paused {
                let didAdvance = consumeAutoAdvanceOnPauseFlag()
                game.statusOrDefault = .inProgress
                try? context.save()
                alertMessage = didAdvance
                    ? "Le tour précédent a été validé. À \(activePlayerName) de jouer !"
                    : "À \(activePlayerName) de jouer !"
                showAlert = true
            }
        }
        .onChange(of: game.activePlayerID) { _, _ in ensureTurnSnapshotInitialized() }
        .onChange(of: scenePhase) { _, phase in
            if phase != .active { autoPauseIfNeeded(reason: "scenePhase=\(phase)") }
        }
        .onDisappear { autoPauseIfNeeded(reason: "onDisappear") }
        .scrollDismissesKeyboard(.interactively)
        .simultaneousGesture(TapGesture().onEnded { hideKeyboard() })
        .navigationTitle(UIStrings.Game.title)
        .toolbar {
#if DEBUG
            ToolbarItem(placement: .navigationBarLeading) {
                Menu {
                    Button("Debug • Terminer maintenant (popup)") {
                        debugFillAllRequiredAndComplete(showNotification: false)
                    }
                    Button("Debug • Terminer avec notification") {
                        NotificationManager.requestAuthorizationIfNeeded()
                        debugFillAllRequiredAndComplete(showNotification: true)
                    }
                } label: { Image(systemName: "ladybug.fill") }
            }
#endif
            ToolbarItem(placement: .navigationBarTrailing) {
                HStack(spacing: 8) {
                    if canShowNextButton {
                        Button("Joueur suivant") { onNextPlayerTapped() }
                            .buttonStyle(.bordered)
                            .controlSize(.small)
                    }
                    Menu {
                        if game.statusOrDefault == .inProgress {
                            Button(UIStrings.Game.pause)  { pauseAndGoHome() }
                            Button(UIStrings.Game.finish) { finishNowAndGoHome() }
                        } else {
                            Text("Partie verrouillée")
                        }
                    } label: { Image(systemName: "ellipsis.circle") }
                }
            }
            ToolbarItemGroup(placement: .keyboard) {
                Spacer()
                Button("Terminé") { hideKeyboard() }
            }
        }
        .alert(alertMessage, isPresented: $showAlert) { Button(UIStrings.Common.ok, role: .cancel) { } }
        .confirmationDialog(
            "Annuler la prime Yams supplémentaire ?",
            isPresented: $showRevokeYams,
            titleVisibility: .visible
        ) {
            Button("Annuler la prime", role: .destructive) {
                if let idx = revokePlayerIdx { revokeExtraYams(for: idx) }
                revokePlayerIdx = nil
            }
            Button("Conserver", role: .cancel) { revokePlayerIdx = nil }
        }
    }


    // MARK: - Suite helpers (from NotationSnapshot)
    private func suiteAllowedValuesFromSnapshot() -> [Int] {
        switch game.notation.suiteBigMode {
        case .singleFixed:
            return [0, game.notation.suiteBigFixed]
        case .splitFixed:
            return [0, game.notation.suiteBigFixed1to5, game.notation.suiteBigFixed2to6]
        @unknown default:
            return [0, 15, 20]
        }
    }
    private func suiteMenuLabelFromSnapshot(_ v: Int) -> String {
        if v == -1 { return UIStrings.Common.dash }
        if v == 0  { return "0" }
        switch game.notation.suiteBigMode {
        case .singleFixed:
            return String(v)
        case .splitFixed:
            if v == game.notation.suiteBigFixed1to5 { return "1 à 5" }
            if v == game.notation.suiteBigFixed2to6 { return "2 à 6" }
            return String(v)
        @unknown default:
            return String(v)
        }
    }
    // Petite suite (from NotationSnapshot)
    private func petiteSuiteAllowedValuesFromSnapshot() -> [Int] {
        return [0, game.notation.rulePetiteSuite.fixedValue]
    }
    private func petiteSuiteMenuLabelFromSnapshot(_ v: Int) -> String {
        if v == -1 { return UIStrings.Common.dash }
        if v == 0  { return "0" }
        return UIStrings.Game.petiteSuite
    }

    // MARK: - Grid (≤4 joueurs compact, ≥5 joueurs labels figés + scroll horizontal)
    @ViewBuilder private func grid() -> some View {
        let needsHorizontal = displayPlayerIDs.count >= 5

        if needsHorizontal {
            HStack(alignment: .top, spacing: 0) {
                labelsColumn()
                ScrollView(.horizontal, showsIndicators: true) {
                    playersColumnsBody()
                        .frame(minWidth: CGFloat(displayPlayerIDs.count) * (minCellWidth + perColumnOuterPad),
                               alignment: .leading)
                }
            }
        } else {
            VStack(spacing: 8) {
                // Header colonnes (noms)
                HStack(spacing: 0) {
                    Text("").frame(width: labelColumnWidth, alignment: .leading)
                    playersColumnsHeader()
                }

                // Section haute
                HStack { Text(UIStrings.Game.upperSection).font(.headline).frame(width: labelColumnWidth, alignment: .leading); Spacer() }
                rowUpper(label: UIStrings.Game.ones,   face: 1, keyPath: \Scorecard.ones)
                rowUpper(label: UIStrings.Game.twos,   face: 2, keyPath: \Scorecard.twos)
                rowUpper(label: UIStrings.Game.threes, face: 3, keyPath: \Scorecard.threes)
                rowUpper(label: UIStrings.Game.fours,  face: 4, keyPath: \Scorecard.fours)
                rowUpper(label: UIStrings.Game.fives,  face: 5, keyPath: \Scorecard.fives)
                rowUpper(label: UIStrings.Game.sixes,  face: 6, keyPath: \Scorecard.sixes)
                totalsRow(label: UIStrings.Game.total1, valueForPlayer: total1Text)

                // Section milieu
                HStack { Text(UIStrings.Game.middleSection).font(.headline).frame(width: labelColumnWidth, alignment: .leading); Spacer() }
                rowMaxMin(label: UIStrings.Game.max, keyPath: \Scorecard.maxVals)
                rowMaxMin(label: UIStrings.Game.min, keyPath: \Scorecard.minVals)
                totalsRow(label: UIStrings.Game.total2, valueForPlayer: total2Text)

                // Section basse
                HStack { Text(UIStrings.Game.bottomSection).font(.headline).frame(width: labelColumnWidth, alignment: .leading); Spacer() }
                rowBottom(label: UIStrings.Game.brelan, keyPath: \Scorecard.brelan,
                          validator: { ValidationEngine.sanitizeBottom($0, rule: game.notation.ruleBrelan) },
                          displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleBrelan) })
                if game.enableChance {
                    rowBottom(label: UIStrings.Game.chance, keyPath: \Scorecard.chance,
                              validator: { ValidationEngine.sanitizeBottom($0, rule: game.notation.ruleChance) },
                              displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleChance) })
                }
                rowBottom(label: UIStrings.Game.full, keyPath: \Scorecard.full,
                          validator: { ValidationEngine.sanitizeBottom($0, rule: game.notation.ruleFull) },
                          displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleFull) })

                HStack(spacing: 0) {
                    Text(UIStrings.Game.suite).frame(width: labelColumnWidth, alignment: .leading)
                    pickerRowPlayersOnly(allowedValues: suiteAllowedValuesFromSnapshot(),
                                         label: UIStrings.Game.suite,
                                         valueToText: GDV_Helpers.displaySuiteValue,
                                         keyPath: \.suite)
                }

                if game.enableSmallStraight {
                    HStack(spacing: 0) {
                        Text(UIStrings.Game.petiteSuite).frame(width: labelColumnWidth, alignment: .leading)
                        pickerRowPlayersOnly(allowedValues: petiteSuiteAllowedValuesFromSnapshot(),
                                             label: UIStrings.Game.petiteSuite,
                                             valueToText: GDV_Helpers.displayPetiteSuiteValue,
                                             keyPath: \.petiteSuite)
                    }
                }

                rowBottom(label: UIStrings.Game.carre, keyPath: \Scorecard.carre,
                          validator: { newVal in
                              let rule = game.notation.ruleCarre
                              if let v = newVal, v == 4, (rule.mode == .rawPlusFixed || rule.mode == .rawTimes) {
                                  return 4
                              }
                              return ValidationEngine.sanitizeBottom(newVal, rule: rule)
                          },
                          displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleCarre) })

                rowBottom(label: UIStrings.Game.yams, keyPath: \Scorecard.yams,
                          validator: { sanitizeYamsForSnapshot($0) },
                          displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleYams) })

                if extraYamsIsEnabled {
                    HStack(spacing: 0) {
                        Text("Prime Yams supplémentaire").frame(width: labelColumnWidth, alignment: .leading)
                        extraYamsRowPlayersOnly()
                    }
                }

                totalsRow(label: UIStrings.Game.total3, valueForPlayer: total3Text)
                totalsRow(label: UIStrings.Game.totalAll, valueForPlayer: totalAllText)
                    .padding(.top, 6)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
    }

    // MARK: - Sous-vues (labels figés & colonnes joueurs)
    // Draw a section header label that may visually overflow to the right when there are ≥5 players
    @ViewBuilder
    private func overflowHeaderLabel(_ text: String) -> some View {
        let needsHorizontal = displayPlayerIDs.count >= 5
        let headerOverflow: CGFloat = 72 // visual extra space to show full title (no layout impact)
        // Base width remains labelColumnWidth to preserve column alignment
        Text(text)
            .font(.headline)
            .lineLimit(1)
            .frame(width: labelColumnWidth, alignment: .leading)
            .overlay(
                Group {
                    if needsHorizontal {
                        Text(text)
                            .font(.headline)
                            .lineLimit(1)
                            .frame(width: labelColumnWidth + headerOverflow, alignment: .leading)
                            .allowsHitTesting(false) // don’t steal horizontal scroll gestures
                    }
                }, alignment: .leading
            )
    }

    private func labelsColumn() -> some View {
        VStack(spacing: 8) {
            Color.clear.frame(height: namesHeaderHeight + namesHeaderBottom)   // ✅

            // Section haute
            overflowHeaderLabel(UIStrings.Game.upperSection)
                .frame(height: headerRowHeight)
            Text(UIStrings.Game.ones).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.twos).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.threes).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.fours).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.fives).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.sixes).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.total1).font(.headline).frame(height: cellRowHeight, alignment: .leading)

            // Section milieu
            overflowHeaderLabel(UIStrings.Game.middleSection)
                .frame(height: headerRowHeight)
            Text(UIStrings.Game.max).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.min).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.total2).font(.headline).frame(height: cellRowHeight, alignment: .leading)

            // Section basse
            overflowHeaderLabel(UIStrings.Game.bottomSection)
                .frame(height: headerRowHeight)
            Text(UIStrings.Game.brelan).frame(height: cellRowHeight, alignment: .leading)
            if game.enableChance { Text(UIStrings.Game.chance).frame(height: cellRowHeight, alignment: .leading) }
            Text(UIStrings.Game.full).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.suite).frame(height: cellRowHeight, alignment: .leading)
            if game.enableSmallStraight { Text(UIStrings.Game.petiteSuite).frame(height: cellRowHeight, alignment: .leading) }
            Text(UIStrings.Game.carre).frame(height: cellRowHeight, alignment: .leading)
            Text(UIStrings.Game.yams).frame(height: cellRowHeight, alignment: .leading)
            if extraYamsIsEnabled { Text("Prime Yams supplémentaire").frame(height: cellRowHeight, alignment: .leading) }
            Text(UIStrings.Game.total3).font(.headline).frame(height: cellRowHeight, alignment: .leading)

            // Total général
            Text(UIStrings.Game.totalAll).font(.headline).padding(.top, 6).frame(height: cellRowHeight, alignment: .leading)
        }
        .frame(width: labelColumnWidth, alignment: .leading)
        .font(.body)
    }

    private func playersColumnsHeader() -> some View {
        HStack(spacing: 0) {
            ForEach(Array(displayPlayerIDs.enumerated()), id: \.element) { index, pid in
                let name = allPlayers.first(where: { $0.id == pid })?.nickname ?? "—"
                let baseColor = colorForPlayerID(pid)

                Text(name)
                    .font(.footnote.weight(.semibold))
                    .lineLimit(1)
                    .minimumScaleFactor(0.7)
                    .frame(minWidth: minCellWidth, maxWidth: .infinity)
                    .padding(.vertical, 6)
                    .background(baseColor.opacity(0.10))
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(baseColor, lineWidth: (game.activePlayerID == pid) ? 2 : 1)
                    )
                    .clipShape(RoundedRectangle(cornerRadius: 8))
                    .padding(.horizontal, 2)
                    .contentShape(Rectangle())
                    .opacity(canChangePlayerByTap ? 1.0 : 0.45)
                    .onTapGesture { setActivePlayer(pid) }
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .frame(height: namesHeaderHeight)
        .padding(.bottom, namesHeaderBottom)
    }

    private func playersColumnsBody() -> some View {
        VStack(spacing: 8) {
            playersColumnsHeader()

            // Section haute
            Color.clear.frame(height: headerRowHeight)
            pickerRowPlayersOnly(allowedValues: allowed(for: 1), label: UIStrings.Game.ones, keyPath: \.ones)
            pickerRowPlayersOnly(allowedValues: allowed(for: 2), label: UIStrings.Game.twos, keyPath: \.twos)
            pickerRowPlayersOnly(allowedValues: allowed(for: 3), label: UIStrings.Game.threes, keyPath: \.threes)
            pickerRowPlayersOnly(allowedValues: allowed(for: 4), label: UIStrings.Game.fours, keyPath: \.fours)
            pickerRowPlayersOnly(allowedValues: allowed(for: 5), label: UIStrings.Game.fives, keyPath: \.fives)
            pickerRowPlayersOnly(allowedValues: allowed(for: 6), label: UIStrings.Game.sixes, keyPath: \.sixes)
            totalsRowPlayersOnly(valueForPlayer: total1Text)

            // Section milieu
            Color.clear.frame(height: headerRowHeight)
            numericRowPlayersOnly(keyPath: \.maxVals, label: UIStrings.Game.max)
            numericRowPlayersOnly(keyPath: \.minVals, label: UIStrings.Game.min)
            totalsRowPlayersOnly(valueForPlayer: total2Text)

            // Section basse
            Color.clear.frame(height: headerRowHeight)
            numericRowPlayersOnly(keyPath: \.brelan,
                                  label: UIStrings.Game.brelan,
                                  validator: { ValidationEngine.sanitizeBottom($0, rule: game.notation.ruleBrelan) },
                                  displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleBrelan) })
            if game.enableChance {
                numericRowPlayersOnly(keyPath: \.chance,
                                      label: UIStrings.Game.chance,
                                      validator: { ValidationEngine.sanitizeBottom($0, rule: game.notation.ruleChance) },
                                      displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleChance) })
            }
            numericRowPlayersOnly(keyPath: \.full,
                                  label: UIStrings.Game.full,
                                  validator: { ValidationEngine.sanitizeBottom($0, rule: game.notation.ruleFull) },
                                  displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleFull) })

            pickerRowPlayersOnly(allowedValues: suiteAllowedValuesFromSnapshot(),
                                 label: UIStrings.Game.suite,
                                 valueToText: GDV_Helpers.displaySuiteValue,
                                 keyPath: \.suite)
            
            if game.enableSmallStraight {
                pickerRowPlayersOnly(allowedValues: petiteSuiteAllowedValuesFromSnapshot(),
                                     label: UIStrings.Game.petiteSuite,
                                     valueToText: GDV_Helpers.displayPetiteSuiteValue,
                                     keyPath: \.petiteSuite)
            }

            numericRowPlayersOnly(keyPath: \.carre,
                                  label: UIStrings.Game.carre,
                                  validator: { newVal in
                                      let rule = game.notation.ruleCarre
                                      if let v = newVal, v == 4, (rule.mode == .rawPlusFixed || rule.mode == .rawTimes) {
                                          return 4
                                      }
                                      return ValidationEngine.sanitizeBottom(newVal, rule: rule)
                                  },
                                  displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleCarre) })

            numericRowPlayersOnly(keyPath: \.yams,
                                  label: UIStrings.Game.yams,
                                  validator: { sanitizeYamsForSnapshot($0) },
                                  displayMap: { ValidationEngine.displayForBottom(stored: $0, rule: game.notation.ruleYams) })

            if extraYamsIsEnabled {
                extraYamsRowPlayersOnly()
            }

            totalsRowPlayersOnly(valueForPlayer: total3Text)
            totalsRowPlayersOnly(valueForPlayer: totalAllText)
                .padding(.top, 6)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    // MARK: - Lignes compactes (≤4 joueurs)
    private func rowUpper(label: String, face: Int, keyPath: WritableKeyPath<Scorecard, [Int]>) -> some View {
        HStack(spacing: 0) {
            Text(label).frame(width: labelColumnWidth, alignment: .leading)
            pickerRowPlayersOnly(allowedValues: allowed(for: face), label: label, keyPath: keyPath)
        }
    }

    private func rowMaxMin(label: String, keyPath: WritableKeyPath<Scorecard, [Int]>) -> some View {
        HStack(spacing: 0) {
            Text(label).frame(width: labelColumnWidth, alignment: .leading)
            numericRowPlayersOnly(keyPath: keyPath, label: label)
        }
    }

    private func rowBottom(label: String,
                           keyPath: WritableKeyPath<Scorecard, [Int]>,
                           validator: ((Int?) -> Int)? = nil,
                           displayMap: ((Int) -> String)? = nil) -> some View {
        HStack(spacing: 0) {
            Text(label).frame(width: labelColumnWidth, alignment: .leading)
            numericRowPlayersOnly(keyPath: keyPath, label: label, validator: validator, displayMap: displayMap)
        }
    }

    // MARK: - Rows (players only)
    private func numericRowPlayersOnly(keyPath: WritableKeyPath<Scorecard, [Int]>,
                                       label: String,
                                       validator: ((Int?) -> Int)? = nil,
                                       displayMap: ((Int) -> String)? = nil) -> some View {
        HStack(spacing: 0) {
            ForEach(displayPlayerIDs, id: \.self) { pid in
                if let playerIdx = scorecardIndexByPlayerID[pid] {
                    let scBinding = $game.scorecards[playerIdx]
                    let isLocked  = scBinding.wrappedValue.isLocked(col: scoreColumnIndex, key: label)
                    let binding   = valueBinding(scBinding, keyPath, scoreColumnIndex)

                    let cfg = NumericRow.Config(
                        value: binding,
                        isLocked: isLocked,
                        isActive: isCellEnabled(for: pid),
                        validator: { newVal in
                            let idx = activeScorecardIndex ?? playerIdx
                            if keyPath == \Scorecard.maxVals {
                                let currentMin = game.scorecards[idx].minVals[scoreColumnIndex]
                                return ValidationEngine.sanitizeMiddleMax(newVal,
                                                                          currentMin: (currentMin >= 0 ? currentMin : nil),
                                                                          strictGreater: (game.notation.middleMode == .bonusGate))
                            } else if keyPath == \Scorecard.minVals {
                                let currentMax = game.scorecards[idx].maxVals[scoreColumnIndex]
                                return ValidationEngine.sanitizeMiddleMin(newVal,
                                                                          currentMax: (currentMax >= 0 ? currentMax : nil),
                                                                          strictGreater: (game.notation.middleMode == .bonusGate))
                            } else if let fn = validator {
                                let raw = newVal ?? -1
                                let sanitized = fn(newVal)
                                // Si l'utilisateur a saisi une valeur positive et que la "sanitization" la modifie,
                                // on signale une entrée invalide (-> NumericRow affichera l'alerte via onInvalidInput).
                                if raw > 0 && sanitized != raw {
                                    return -1
                                }
                                return sanitized
                            } else {
                                return newVal ?? -1
                            }
                        },
                        displayMap: displayMap,
                        valueFont: badgeFont,
                        effectiveFont: cellFont,
                        contentPadding: cellPadding,
                        allowedRange: (label == UIStrings.Game.carre ? (4...30) : (5...30)),
                        allowZero: (label == UIStrings.Game.brelan
                                     || label == UIStrings.Game.chance
                                     || label == UIStrings.Game.full
                                     || label == UIStrings.Game.suite
                                     || label == UIStrings.Game.petiteSuite
                                     || label == UIStrings.Game.carre
                                     || label == UIStrings.Game.yams),
                       onInvalidInput: { v in
                           alertMessage = "La valeur \(v) n’est pas valide pour \(label)."
                           showAlert = true
                       }
                    )

                    NumericRow(cfg)
                        .frame(minWidth: minCellWidth, maxWidth: .infinity, alignment: .leading)
                        .frame(height: cellRowHeight)
                        .contextMenu {
                            Button(UIStrings.Common.validate) {
                                scBinding.wrappedValue.setLocked(true, col: scoreColumnIndex, key: label)
                                try? context.save()
                            }
                            Button(UIStrings.Common.clear) { binding.wrappedValue = -1 }
                        }
                        .disabled(isLocked || !isCellEnabled(for: pid))
                        .padding(.horizontal, 2)
                }
            }
        }
    }

    private func pickerRowPlayersOnly(allowedValues: [Int],
                                      label: String,
                                      valueToText: ((Int) -> String)? = nil,
                                      keyPath: WritableKeyPath<Scorecard, [Int]>) -> some View {
        HStack(spacing: 0) {
            ForEach(displayPlayerIDs, id: \.self) { pid in
                if let playerIdx = scorecardIndexByPlayerID[pid] {
                    let scBinding = $game.scorecards[playerIdx]
                    let isLocked  = scBinding.wrappedValue.isLocked(col: scoreColumnIndex, key: label)
                    let binding   = valueBinding(scBinding, keyPath, scoreColumnIndex)

                    Menu {
                        Picker("Valeur", selection: binding) {
                            ForEach([-1] + allowedValues, id: \.self) { v in
                                let title: String = {
                                    if label == UIStrings.Game.suite {
                                        return suiteMenuLabelFromSnapshot(v)
                                    } else if label == UIStrings.Game.petiteSuite {
                                        return petiteSuiteMenuLabelFromSnapshot(v)
                                    } else {
                                        return valueToText.map { $0(v) } ?? (v == -1 ? UIStrings.Common.dash : String(v))
                                    }
                                }()
                                Text(title).tag(v)
                            }
                        }
                    } label: {
                        Text(valueToText.map { $0(binding.wrappedValue) } ?? (binding.wrappedValue == -1 ? UIStrings.Common.dash : String(binding.wrappedValue)))
                            .font(cellFont)
                            .frame(minWidth: minCellWidth, maxWidth: .infinity)
                            .frame(height: cellRowHeight)
                            .multilineTextAlignment(.center)
                            .foregroundColor(.primary)
                            .padding(.horizontal, cellPadding)
                            .background(cellBackground(col: playerIdx, isOpen: binding.wrappedValue == -1))
                            .clipShape(RoundedRectangle(cornerRadius: 8))
                    }
                    .disabled(isLocked || !isCellEnabled(for: pid))
                    .contextMenu {
                        Button(UIStrings.Common.validate) {
                            scBinding.wrappedValue.setLocked(true, col: scoreColumnIndex, key: label)
                            try? context.save()
                        }
                        Button(UIStrings.Common.clear) { binding.wrappedValue = -1 }
                    }
                    .padding(.horizontal, 2)
                }
            }
        }
    }

    // MARK: - Totaux
    private func middleCanCompute(playerIdx: Int) -> Bool {
        let sc = game.scorecards[playerIdx]
        switch game.notation.middleMode {
        case .multiplier:
            return sc.maxVals[scoreColumnIndex] >= 0
            &&     sc.minVals[scoreColumnIndex] >= 0
            &&     sc.ones[scoreColumnIndex]    >= 0
        case .bonusGate:
            return sc.maxVals[scoreColumnIndex] >= 0
            &&     sc.minVals[scoreColumnIndex] >= 0
        }
    }

    private func total1Text(_ playerIdx: Int) -> String {
        let sc = game.scorecards[playerIdx]
        return String(StatsEngine.upperTotal(sc: sc, game: game, col: scoreColumnIndex))
    }

    private func total2Text(_ playerIdx: Int) -> String {
        guard middleCanCompute(playerIdx: playerIdx) else { return UIStrings.Common.dash }
        let sc = game.scorecards[playerIdx]
        return String(StatsEngine.middleTotal(sc: sc, game: game, col: scoreColumnIndex))
    }

    private func total3Text(_ playerIdx: Int) -> String {
        let sc = game.scorecards[playerIdx]
        return String(StatsEngine.bottomTotal(sc: sc, game: game, col: scoreColumnIndex))
    }

    private func totalAllText(_ playerIdx: Int) -> String {
        let sc = game.scorecards[playerIdx]
        let upper  = StatsEngine.upperTotal(sc: sc, game: game, col: scoreColumnIndex)
        let bottom = StatsEngine.bottomTotal(sc: sc, game: game, col: scoreColumnIndex)
        let middle = middleCanCompute(playerIdx: playerIdx)
            ? StatsEngine.middleTotal(sc: sc, game: game, col: scoreColumnIndex)
            : 0
        return String(upper + middle + bottom)
    }

    private func totalScore(for playerID: UUID) -> Int {
        if let idx = game.scorecards.firstIndex(where: { $0.playerID == playerID }) {
            return Int(totalAllText(idx)) ?? 0
        }
        return 0
    }

    @ViewBuilder
    private func totalsRowPlayersOnly(valueForPlayer: @escaping (_ playerIdx: Int) -> String) -> some View {
        HStack(spacing: 0) {
            ForEach(displayPlayerIDs, id: \.self) { pid in
                if let playerIdx = scorecardIndexByPlayerID[pid] {
                    let text = valueForPlayer(playerIdx)
                    Text(text)
                        .font(.headline)
                        .frame(minWidth: minCellWidth, maxWidth: .infinity)
                        .frame(height: cellRowHeight)
                        .padding(.horizontal, cellPadding)
                        .background(cellBackground(col: playerIdx, isOpen: (text == UIStrings.Common.dash || text == "—")))
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        .padding(.horizontal, 2)
                }
            }
        }
    }

    @ViewBuilder
    private func totalsRow(label: String, valueForPlayer: @escaping (_ playerIdx: Int) -> String) -> some View {
        HStack(spacing: 0) {
            Text(label).font(.headline).frame(width: labelColumnWidth, alignment: .leading)
            totalsRowPlayersOnly(valueForPlayer: valueForPlayer)
        }
    }

    // MARK: - Extra Yams
    private var extraYamsIsEnabled: Bool { game.enableExtraYamsBonus }

    private func yamsAlreadyScored(_ sc: Scorecard, col: Int) -> Bool {
        guard sc.yams.indices.contains(col) else { return false }
        return sc.yams[col] > 0
    }

    @ViewBuilder
    private func extraYamsRowPlayersOnly() -> some View {
        HStack(spacing: 0) {
            ForEach(displayPlayerIDs, id: \.self) { pid in
                if let playerIdx = scorecardIndexByPlayerID[pid] {
                    let scBinding = $game.scorecards[playerIdx]
                    let awarded = scBinding.wrappedValue.extraYamsAwarded[scoreColumnIndex]
                    let eligible = yamsAlreadyScored(scBinding.wrappedValue, col: scoreColumnIndex)
                    let isLockedExtra = scBinding.wrappedValue.isLocked(col: scoreColumnIndex, key: "ExtraYamsBonus")
                    let isActivePlayer = (game.activePlayerID == pid)

                    ZStack(alignment: .topTrailing) {
                        // Base cell background + content
                        RoundedRectangle(cornerRadius: 8)
                            .fill(cellBackground(col: playerIdx, isOpen: !awarded))

                        if awarded {
                            // Compact awarded presentation
                            HStack(spacing: 6) {
                                Image(systemName: "checkmark.seal.fill")
                                    .imageScale(.medium)
                                Text("\(game.notation.extraYamsBonusValue)")
                                    .font(badgeFont)
                                    .lineLimit(1)
                                    .minimumScaleFactor(0.75)
                                Spacer(minLength: 0)
                            }
                            .padding(.horizontal, cellPadding)

                            if isActivePlayer && !isLockedExtra {
                                // Revoke button as a small overlay in the corner
                                Button(role: .destructive) {
                                    revokePlayerIdx = playerIdx
                                    showRevokeYams = true
                                } label: {
                                    Image(systemName: "xmark.circle.fill")
                                        .imageScale(.medium)
                                }
                                .buttonStyle(.borderless)
                                .padding(6)
                            }
                        } else if eligible && isActivePlayer {
                            // Compact "grant" button
                            Button {
                                var arr = scBinding.wrappedValue.extraYamsAwarded
                                if scoreColumnIndex >= arr.count {
                                    arr.append(contentsOf: Array(repeating: false, count: scoreColumnIndex - arr.count + 1))
                                }
                                arr[scoreColumnIndex] = true
                                scBinding.wrappedValue.extraYamsAwarded = arr
                                //scBinding.wrappedValue.setLocked(true, col: scoreColumnIndex, key: "ExtraYamsBonus")
                                try? context.save()
                            } label: {
                                Text("+")
                                    .font(.system(size: max(14, min(22, minCellWidth * 0.6)), weight: .semibold))
                                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                                    .padding(.horizontal, cellPadding)
                                    .contentShape(Rectangle())
                            }
                            .buttonStyle(.plain)
                        } else {
                            // Not eligible or not active → dash, centered
                            Text(UIStrings.Common.dash)
                                .font(cellFont)
                                .lineLimit(1)
                                .minimumScaleFactor(0.8)
                                .padding(.horizontal, cellPadding)
                        }
                    }
                    .frame(minWidth: minCellWidth, maxWidth: .infinity)
                    .frame(height: cellRowHeight)
                    .contextMenu {
                        if awarded && !isLockedExtra {
                            Button("Retirer la prime", role: .destructive) {
                                revokeExtraYams(for: playerIdx)
                            }
                        } else {
                            Button("Conditions") {
                                tipText = "Prime accordée uniquement si le Yams est déjà validé (≠ 0 et ≠ —)."
                                showTip = true
                            }
                        }
                    }
                    .disabled(!isActivePlayer)
                    .padding(.horizontal, 2)
                }
            }
        }
    }

    private func sanitizeYamsForSnapshot(_ newVal: Int?) -> Int {
        guard let v = newVal else { return -1 }
        if v == 0 { return 0 }
        let bases: Set<Int> = [5, 10, 15, 20, 25, 30]
        let rule = game.notation.ruleYams
        switch rule.mode {
        case .fixed: return rule.fixedValue
        default:     return bases.contains(v) ? v : -1
        }
    }

    // MARK: - Helpers communs
    private func allowed(for face: Int) -> [Int] { Validators.allowedUpperValues(face: face) }

    private func valueBinding(_ sc: Binding<Scorecard>, _ keyPath: WritableKeyPath<Scorecard, [Int]>, _ col: Int) -> Binding<Int> {
        Binding<Int>(
            get: {
                let arr = sc.wrappedValue[keyPath: keyPath]
                return (col < arr.count && col >= 0) ? arr[col] : -1
            },
            set: { newVal in
                var arr = sc.wrappedValue[keyPath: keyPath]
                if col < arr.count && col >= 0 {
                    arr[col] = newVal
                    sc.wrappedValue[keyPath: keyPath] = arr
                }
            }
        )
    }


    // MARK: - DEBUG
    #if DEBUG
    private func ensureCapacity(_ arr: inout [Int], at idx: Int) {
        if idx >= arr.count { arr.append(contentsOf: Array(repeating: -1, count: idx - arr.count + 1)) }
    }
    private func debugSetValue(playerIdx: Int, keyPath: WritableKeyPath<Scorecard, [Int]>, value: Int) {
        var arr = game.scorecards[playerIdx][keyPath: keyPath]
        ensureCapacity(&arr, at: scoreColumnIndex)
        arr[scoreColumnIndex] = value
        game.scorecards[playerIdx][keyPath: keyPath] = arr
    }
    private func debugFillAllRequiredAndComplete(showNotification: Bool = false) {
        for i in game.scorecards.indices {
            // haute
            debugSetValue(playerIdx: i, keyPath: \.ones,   value: 0)
            debugSetValue(playerIdx: i, keyPath: \.twos,   value: 0)
            debugSetValue(playerIdx: i, keyPath: \.threes, value: 0)
            debugSetValue(playerIdx: i, keyPath: \.fours,  value: 0)
            debugSetValue(playerIdx: i, keyPath: \.fives,  value: 0)
            debugSetValue(playerIdx: i, keyPath: \.sixes,  value: 0)
            // milieu
            debugSetValue(playerIdx: i, keyPath: \.maxVals, value: 0)
            debugSetValue(playerIdx: i, keyPath: \.minVals, value: 0)
            // basse
            debugSetValue(playerIdx: i, keyPath: \.brelan, value: 0)
            if game.enableChance { debugSetValue(playerIdx: i, keyPath: \.chance, value: 0) }
            debugSetValue(playerIdx: i, keyPath: \.full,  value: 0)
            debugSetValue(playerIdx: i, keyPath: \.suite, value: 0)
            if game.enableSmallStraight { debugSetValue(playerIdx: i, keyPath: \.petiteSuite, value: 0) }
            debugSetValue(playerIdx: i, keyPath: \.carre, value: 0)
            debugSetValue(playerIdx: i, keyPath: \.yams,  value: 0)
        }
        game.statusOrDefault = .completed
        game.endedAt = Date()
        try? context.save()

        let ranking: [(String, Int)] = orderedPlayers
            .map { ($0.nickname, totalScore(for: $0.id)) }
            .sorted { $0.1 > $1.1 }

        if showNotification {
            NotificationManager.postEndGame(
                winnerName: ranking.first?.0 ?? "—",
                gameName: game.name,
                rankings: ranking
            )
        } else {
            endGameEntries = ranking.map { .init(name: $0.0, score: $0.1) }
            showCongrats = true
        }
    }
    #endif
}



================================================================================
FILE: YamSheet/Views/games/GamesListView.swift
================================================================================

import SwiftUI
import SwiftData

struct GamesListView: View {
    @Environment(\.modelContext) private var context
    @Query(sort: \Game.createdAt, order: .reverse) private var games: [Game]
    @State private var showingNewGame = false

    // Filtre : Actives (en cours + en pause) / Terminées
    enum Filter: String, CaseIterable, Identifiable {
        case active    = "Actives"
        case completed = "Terminées"
        var id: String { rawValue }
    }
    @State private var filter: Filter = .active

    private var filteredGames: [Game] {
        games.filter { g in
            switch filter {
            case .active:
                return g.statusOrDefault == .inProgress || g.statusOrDefault == .paused
            case .completed:
                return g.statusOrDefault == .completed
            }
        }
    }

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Segmented control
                Picker("Filtre", selection: $filter) {
                    ForEach(Filter.allCases) { f in
                        Text(f.rawValue).tag(f)
                    }
                }
                .pickerStyle(.segmented)
                .padding([.horizontal, .top])

                // Liste filtrée
                if filteredGames.isEmpty {
                    ContentUnavailableView(
                        "Aucune partie",
                        systemImage: "rectangle.on.rectangle.slash",
                        description: Text("Change le filtre ou crée une nouvelle partie.")
                    )
                    .padding()
                } else {
                    List {
                        ForEach(filteredGames) { game in
                            NavigationLink(value: game.id) {
                                row(for: game)
                            }
                        }
                        .onDelete { indexSet in
                            indexSet.map { filteredGames[$0] }.forEach(context.delete)
                            try? context.save()
                        }
                    }
                    .listStyle(.insetGrouped)
                }
            }
            .navigationTitle(UIStrings.Common.games)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button {
                        showingNewGame = true
                    } label: {
                        Label("Nouvelle partie", systemImage: "plus")
                    }
                }
            }
            .sheet(isPresented: $showingNewGame) {
                NewGameView()
                    .presentationDetents([.large])
            }
            .navigationDestination(for: UUID.self) { id in
                if let game = games.first(where: { $0.id == id }) {
                    GameDetailView(game: game)
                } else {
                    Text("Partie introuvable").foregroundStyle(.secondary)
                }
            }
            .task {
                SampleData.ensureSamples(context)
            }
        }
    }

    // MARK: - Row
    @ViewBuilder
    private func row(for game: Game) -> some View {
        VStack(alignment: .leading, spacing: 6) {
            Text("\(UIStrings.Common.game) \(UIStrings.Common.dash)  \(game.createdAt.formatted(date: .abbreviated, time: .shortened))")
                .font(.headline)

            if !game.comment.isEmpty {
                Text(game.comment).foregroundStyle(.secondary)
            }

            HStack {
                Spacer()
                statusBadge(for: game.statusOrDefault)
            }
            .font(.caption)
        }
    }

    // MARK: - Status badge
    @ViewBuilder
    private func statusBadge(for status: GameStatus) -> some View {
        let (text, color): (String, Color) = {
            switch status {
            case .inProgress: return ("En cours", .blue)
            case .paused:     return ("En pause", .orange)
            case .completed:  return ("Terminée", .green)
            }
        }()

        Text(text)
            .font(.caption)
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(color.opacity(0.15))
            .clipShape(Capsule())
    }
}




================================================================================
FILE: YamSheet/Views/games/NewGameView.swift
================================================================================

import SwiftUI
import SwiftData

// Une seule source de vérité pour la feuille présentée
private enum CreationSheet: Identifiable {
    case newPlayer
    case newNotation
    var id: Int { hashValue }
}

struct NewGameView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context

    // Données
    @Query(sort: \Player.nickname) private var players: [Player]
    @Query(sort: \Notation.name)  private var notations: [Notation]
    @Query                       private var settings: [AppSettings]

    // Sélections
    @State private var selectedPlayerIDs: Set<Player.ID> = []
    @State private var selectedNotationID: Notation.ID? = nil

    //Prime Xtra Yams
    @State private var enableExtraYamsBonus: Bool = true
    
    // Options
    @State private var enableChance: Bool = true
    @State private var enableSmallStraight: Bool = true
    @State private var comment: String = ""
    @State private var gameName: String = ""

    // Navigation directe vers la partie créée
    @State private var createdGame: Game? = nil

    // Feuille modale unique
    @State private var activeSheet: CreationSheet?

    // Helpers
    private var selectedNotation: Notation? {
        notations.first(where: { $0.id == selectedNotationID }) ?? notations.first
    }
    private var defaultGameName: String {
        let df = DateFormatter()
        df.locale = Locale(identifier: "fr_FR")
        df.dateFormat = "dd/MM/yyyy"
        return "Nom \(df.string(from: Date()))"
    }

    var body: some View {
        NavigationStack {
            Form {
                // --- NOM EN PREMIER ---
                Section("Nom de la partie") {
                    TextField("Nom :", text: $gameName)
                        .textInputAutocapitalization(.words)
                }

                // --- JOUEURS (interrupteurs isOn) ---
                Section("Joueurs") {
                    if players.isEmpty {
                        Text("Aucun joueur.").foregroundStyle(.secondary)
                    } else {
                        ForEach(players) { p in
                            Toggle(isOn: Binding(
                                get: { selectedPlayerIDs.contains(p.id) },
                                set: { isOn in
                                    if isOn { selectedPlayerIDs.insert(p.id) }
                                    else     { selectedPlayerIDs.remove(p.id) }
                                }
                            )) {
                                Text(p.nickname)
                            }
                        }
                    }
                    Button {
                        activeSheet = .newPlayer
                    } label: {
                        Label("Nouveau joueur", systemImage: "plus.circle")
                    }
                }

                // --- NOTATION ---
                Section("Notation") {
                    if notations.isEmpty {
                        Text("Aucune notation. Créez-en une.").foregroundStyle(.secondary)
                    } else {
                        Picker("Choisir une notation", selection: Binding(
                            get: { selectedNotationID ?? notations.first?.id },
                            set: { selectedNotationID = $0 }
                        )) {
                            ForEach(notations) { n in
                                Text(n.name).tag(n.id as Notation.ID?)
                            }
                        }
                    }
                    Button {
                        activeSheet = .newNotation
                    } label: {
                        Label("Créer une notation", systemImage: "plus.square.on.square")
                    }
                }

                // --- OPTIONS ---
                Section("Options") {
                    Toggle("Inclure Chance", isOn: $enableChance)
                    Toggle("Activer Petite suite", isOn: $enableSmallStraight)
                    Toggle("Activer Prime Yams supplémentaire", isOn: $enableExtraYamsBonus)
                    TextField("Commentaire", text: $comment)
                }

                // --- ACTION (gros bouton plein) ---
                Section {
                    Button {
                        createGame()
                    } label: {
                        Text("Créer la partie")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.borderedProminent)
                    .controlSize(.large)
                    .disabled(selectedPlayerIDs.isEmpty || selectedNotation == nil)
                }
            }
            .navigationTitle("Nouvelle partie")
            .navigationDestination(item: $createdGame) { g in
                GameDetailView(game: g)
                    .navigationBarBackButtonHidden(true) // pas de “Back”
            }
            .onAppear {
                if gameName.isEmpty { gameName = defaultGameName }
                if selectedNotationID == nil { selectedNotationID = notations.first?.id }
            }
            // --- FEUILLE MODALE UNIQUE ---
            .sheet(item: $activeSheet) { which in
                switch which {
                case .newPlayer:
                    NavigationStack {
                        NewPlayerView(onCreated: { newPlayer in
                            // auto-sélectionner le nouveau joueur
                            selectedPlayerIDs.insert(newPlayer.id)
                            activeSheet = nil
                        })
                        .navigationTitle("Nouveau joueur")
                    }
                    .presentationDetents([.large])
                    .presentationDragIndicator(.visible)

                case .newNotation:
                    // ► Utilise NotationEditorView avec callback de création
                    NavigationStack {
                        NotationEditorView(onCreated: { newNotation in
                            // auto-sélectionner la nouvelle notation
                            selectedNotationID = newNotation.id
                            activeSheet = nil
                        })
                        .navigationTitle("Nouvelle notation")
                        // IMPORTANT : plus de bouton "Fermer" redondant ici
                    }
                    .presentationDetents([.large])
                    .presentationDragIndicator(.visible)
                }
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: .closeToGamesList)) { _ in
            // Ferme la feuille de création si on termine/mete en pause depuis GameDetailView
            dismiss()
        }
    }

    // MARK: - Création de la partie
    private func createGame() {
        guard let notation = selectedNotation else { return }
        let chosenPlayers = players.filter { selectedPlayerIDs.contains($0.id) }
        guard !chosenPlayers.isEmpty else { return }

        // Nom final
        let nameToUse = gameName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
            ? defaultGameName
            : gameName

        // Récupère/Crée AppSettings
        let appSettings: AppSettings = {
            if let s = settings.first { return s }
            let s = AppSettings()
            context.insert(s)
            return s
        }()

        // Snapshot de la notation (si Game attend un NotationSnapshot)
        let snapshot = notation.snapshot()

        // IMPORTANT : utilise l'init réel de Game
        let game = Game(settings: appSettings, notation: snapshot, columns: 1, comment: comment)

        // Nom + options par partie
        game.name = nameToUse
        game.enableChance = enableChance
        game.enableSmallStraight = enableSmallStraight
        game.enableExtraYamsBonus = enableExtraYamsBonus   // Prime Yams supplémentaire
        
        // ►► AJOUT : enregistre les participants de CETTE partie
        game.participantIDs = chosenPlayers.map(\.id)

        // Scorecards pour chaque joueur
        for p in chosenPlayers {
            let sc = Scorecard(playerID: p.id, columns: 1)
            sc.game = game
            context.insert(sc)
        }

        // Sauvegarde & navigation directe vers la feuille (sans retour)
        context.insert(game)
        try? context.save()

        activeSheet = nil
        createdGame = game
    }
}




================================================================================
FILE: YamSheet/Views/games/NewPlayerInlineSheet.swift
================================================================================

//
//  NewPlayerInlineSheet.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 30/08/2025.
//

import SwiftUI

struct NewPlayerInlineSheet: View {
    @Environment(\.dismiss) private var dismiss
    @State private var nickname: String = ""
    var onCreate: (String) -> Void

    var body: some View {
        NavigationStack {
            Form {
                Section("Nom du joueurOUOUOU") {
                    TextField("Pseudo", text: $nickname)
                }
                Section {
                    Button("Créer") {
                        guard !nickname.trimmingCharacters(in: .whitespaces).isEmpty else { return }
                        onCreate(nickname.trimmingCharacters(in: .whitespaces))
                        dismiss()
                    }
                    .disabled(nickname.trimmingCharacters(in: .whitespaces).isEmpty)
                }
            }
            .navigationTitle("Nouveau joueur")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Annuler") { dismiss() }
                }
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/notations/NotationDetailView.swift
================================================================================

//
//  NotationDetailView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/08/2025.
//

import SwiftUI
import SwiftData

struct NotationDetailView: View {
    
 
    @Environment(\.modelContext) private var context
    @Bindable var notation: Notation // ← IMPORTANT
    @State private var showSaved = false
    
    var body: some View {
        Form {
            Section("Nom") {
                TextField("Nom de la notation", text: $notation.name)
            }
            
            Section(UIStrings.Notation.tooltips) {
                TextField(UIStrings.Notation.tooltipUpper, text: Binding(
                    get: { notation.tooltipUpper ?? "" },
                    set: { notation.tooltipUpper = $0 }
                ))
                TextField(UIStrings.Notation.tooltipMiddle, text: Binding(
                    get: { notation.tooltipMiddle ?? "" },
                    set: { notation.tooltipMiddle = $0 }
                ))
                TextField(UIStrings.Notation.tooltipBottom, text: Binding(
                    get: { notation.tooltipBottom ?? "" },
                    set: { notation.tooltipBottom = $0 }
                ))
            }
            
            Section(UIStrings.Notation.upperSection) {
                Stepper("\(UIStrings.Notation.upperBonusThresholdLabel) : \(notation.upperBonusThreshold)",
                        value: $notation.upperBonusThreshold, in: 0...200)

                Stepper("\(UIStrings.Notation.upperBonusLabel) : \(notation.upperBonusValue)",
                        value: $notation.upperBonusValue, in: 0...200)

                if let tip = notation.tooltipUpper, !tip.isEmpty {
                    Text(tip).font(.footnote).foregroundStyle(.secondary)
                }
            }
            
            Section(UIStrings.Notation.middleSection) {
                Picker(UIStrings.Notation.rulePicker, selection: $notation.middleModeRaw) {
                    Text(UIStrings.Notation.middleLabel(.multiplier)).tag(MiddleRuleMode.multiplier.rawValue)
                    Text(UIStrings.Notation.middleLabel(.bonusGate)).tag(MiddleRuleMode.bonusGate.rawValue)
                }
                Text(
                    StatsEngine.middleTooltip(
                        mode: MiddleRuleMode(rawValue: notation.middleModeRaw) ?? .multiplier,
                        threshold: notation.middleBonusSumThreshold,
                        bonus: notation.middleBonusValue
                    )
                )
                .font(.footnote)
                .foregroundStyle(.secondary)

                if MiddleRuleMode(rawValue: notation.middleModeRaw) == .bonusGate {
                    Stepper("\(UIStrings.Notation.thresholdSum) : \(notation.middleBonusSumThreshold)",
                            value: $notation.middleBonusSumThreshold, in: 0...200)
                    Stepper("\(UIStrings.Notation.bonus) : \(notation.middleBonusValue)",
                            value: $notation.middleBonusValue, in: 0...200)
                }
            }



            
            Section("Section basse — règles") {
                FigureRuleRow(title: "Brelan", rule: $notation.ruleBrelan)
                FigureRuleRow(title: "Chance", rule: $notation.ruleChance)
                FigureRuleRow(title: "Full", rule: $notation.ruleFull)

                // Grande suite (5 dés) — config dédiée
                Section(UIStrings.Notation.bigSuite) {
                    Picker(UIStrings.Notation.modeLabel, selection: $notation.suiteBigModeRaw) {
                        Text(UIStrings.Notation.suiteModeLabel(.singleFixed)).tag(SuiteBigMode.singleFixed.rawValue)
                        Text(UIStrings.Notation.suiteModeLabel(.splitFixed)).tag(SuiteBigMode.splitFixed.rawValue)
                    }

                    if notation.suiteBigMode == .singleFixed {
                        HStack {
                            Text(UIStrings.Notation.valueFixed).font(.caption).foregroundStyle(.secondary)
                            Spacer()
                            CompactWheelPicker(value: $notation.suiteBigFixed,
                                               range: 0...100,
                                               title: UIStrings.Notation.valueFixed)
                        }
                    } else {
                        HStack {
                            Text(UIStrings.Notation.suite15Lbl).font(.caption).foregroundStyle(.secondary)
                            Spacer()
                            CompactWheelPicker(value: $notation.suiteBigFixed1to5,
                                               range: 0...100,
                                               title: UIStrings.Notation.suite15Lbl)
                        }
                        HStack {
                            Text(UIStrings.Notation.suite20Lbl).font(.caption).foregroundStyle(.secondary)
                            Spacer()
                            CompactWheelPicker(value: $notation.suiteBigFixed2to6,
                                               range: 0...100,
                                               title: UIStrings.Notation.suite20Lbl)
                        }
                    }
                }




                // Petite suite (4 dés) : on garde FigureRule (.fixed recommandé)
                FigureRuleRow(title: "Petite suite", rule: $notation.rulePetiteSuite)

                
                
                FigureRuleRow(title: "Carré", rule: $notation.ruleCarre)
                FigureRuleRow(title: "Yams", rule: $notation.ruleYams)

                Section("Prime Yams supplémentaire") {
                    HStack {
                        Text("Montant")
                        Spacer()
                        TextField("0", value: $notation.extraYamsBonusValue, format: .number)
                            .keyboardType(.numberPad)
                            .frame(width: 80)
                            .multilineTextAlignment(.trailing)
                    }
                    Text("Astuce : mettre 0 pour désactiver la prime dans la notation. L’activation finale se fait lors de la création d’une partie.")
                        .font(.footnote)
                        .foregroundStyle(.secondary)
                }
                .onChange(of: notation.extraYamsBonusValue) { oldVal, newVal in
                    notation.extraYamsBonusEnabled = newVal > 0
                    try? context.save()
                }

                
            }
        }
        .navigationTitle(notation.name)
        .toolbar {
            ToolbarItem(placement: .confirmationAction) {
                Button("Enregistrer") {
                    try? context.save()
                    showSaved = true
                }
            }
        }
        .alert("Enregistré ✅", isPresented: $showSaved) {
            Button("OK", role: .cancel) { }
        }
    }
}



struct FigureRuleRow: View {
    let title: String
    @Binding var rule: FigureRule

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(title)
                Spacer()
                Picker("", selection: Binding(
                    get: { rule.mode.rawValue },
                    set: { rule.mode = BottomRuleMode(rawValue: $0) ?? .raw }
                )) {
                    ForEach(BottomRuleMode.allCases) { m in
                        Text(UIStrings.Notation.bottomLabel(m)).tag(m.rawValue)
                    }
                }
                .pickerStyle(.menu)
            }

            if rule.mode == .fixed {
                HStack {
                    Text(UIStrings.Notation.valueFixed).font(.caption).foregroundStyle(.secondary)
                    Spacer()
                    CompactWheelPicker(value: $rule.fixedValue,
                                       range: 0...200,
                                       title: UIStrings.Notation.valueFixed)
                }
            } else if rule.mode == .rawPlusFixed {
                HStack {
                    Text(UIStrings.Notation.primeFixed).font(.caption).foregroundStyle(.secondary)
                    Spacer()
                    CompactWheelPicker(value: $rule.fixedValue,
                                       range: 0...200,
                                       title: UIStrings.Notation.primeFixed)
                }
            } else if rule.mode == .rawTimes {
                HStack {
                    Text(UIStrings.Notation.multiplier).font(.caption).foregroundStyle(.secondary)
                    Spacer()
                    CompactWheelPicker(value: $rule.multiplier,
                                       range: 1...10,
                                       title: UIStrings.Notation.multiplier,
                                       display: { "×\($0)" })
                }
            }

            TextField(UIStrings.Notation.figureTooltipPlaceholder, text: Binding(
                get: { rule.tooltip ?? "" },
                set: { rule.tooltip = $0 }
            ))
            .font(.caption)
            .foregroundStyle(.secondary)
        }
        .animation(.default, value: rule.mode)
    }
}






================================================================================
FILE: YamSheet/Views/notations/NotationEditorView.swift
================================================================================

//
//  NotationEditorView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/08/2025.
//
import SwiftUI
import SwiftData

struct NotationEditorView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context
    
    var onCreated: ((Notation) -> Void)? = nil

    @State private var local = Notation(
        name: "Classique",
        tooltipUpper: "Atteignez le seuil pour gagner le bonus.",
        tooltipMiddle: nil, // non édité : affiché via StatsEngine.middleTooltip
        tooltipBottom: "Chaque figure peut être calculée différemment."
    )

    var body: some View {
        NavigationStack {
            Form {
                // Nom
                Section(UIStrings.Notation.name) {
                    TextField(UIStrings.Notation.name, text: $local.name)
                }

                // Tooltips : Upper & Bottom éditables ; Middle est affiché en lecture seule plus bas
                Section(UIStrings.Notation.tooltips) {
                    TextField(UIStrings.Notation.tooltipUpper, text: Binding(
                        get: { local.tooltipUpper ?? "" },
                        set: { local.tooltipUpper = $0 }
                    ))
                    TextField(UIStrings.Notation.tooltipBottom, text: Binding(
                        get: { local.tooltipBottom ?? "" },
                        set: { local.tooltipBottom = $0 }
                    ))
                }

                // Section haute
                Section(UIStrings.Notation.upperSection) {
                    Stepper("\(UIStrings.Notation.upperBonusThresholdLabel) : \(local.upperBonusThreshold)",
                            value: $local.upperBonusThreshold, in: 0...200)
                    Stepper("\(UIStrings.Notation.upperBonusLabel) : \(local.upperBonusValue)",
                            value: $local.upperBonusValue, in: 0...200)
                }

                // Section milieu (tooltip non éditable + champs conditionnels)
                Section(UIStrings.Notation.middleSection) {
                    Picker(UIStrings.Notation.rulePicker, selection: $local.middleModeRaw) {
                        Text(UIStrings.Notation.middleLabel(.multiplier)).tag(MiddleRuleMode.multiplier.rawValue)
                        Text(UIStrings.Notation.middleLabel(.bonusGate)).tag(MiddleRuleMode.bonusGate.rawValue)
                    }

                    // Tooltip auto selon le mode choisi (non éditable)
                    Text(
                        StatsEngine.middleTooltip(
                            mode: MiddleRuleMode(rawValue: local.middleModeRaw) ?? .multiplier,
                            threshold: local.middleBonusSumThreshold,
                            bonus: local.middleBonusValue
                        )
                    )
                    .font(.footnote)
                    .foregroundStyle(.secondary)

                    if MiddleRuleMode(rawValue: local.middleModeRaw) == .bonusGate {
                        Stepper("\(UIStrings.Notation.thresholdSum) : \(local.middleBonusSumThreshold)",
                                value: $local.middleBonusSumThreshold, in: 0...200)
                        Stepper("\(UIStrings.Notation.bonus) : \(local.middleBonusValue)",
                                value: $local.middleBonusValue, in: 0...200)
                    }
                }

                // Section basse — Grande suite (5 dés)
                Section(UIStrings.Notation.bigSuite) {
                    Picker(UIStrings.Notation.modeLabel, selection: $local.suiteBigModeRaw) {
                        Text(UIStrings.Notation.suiteModeLabel(.singleFixed)).tag(SuiteBigMode.singleFixed.rawValue)
                        Text(UIStrings.Notation.suiteModeLabel(.splitFixed)).tag(SuiteBigMode.splitFixed.rawValue)
                    }


                    if local.suiteBigMode == .singleFixed {
                        HStack {
                            Text(UIStrings.Notation.valueFixed).font(.caption).foregroundStyle(.secondary)
                            Spacer()
                            CompactWheelPicker(value: $local.suiteBigFixed,
                                               range: 0...100,
                                               title: UIStrings.Notation.valueFixed)
                        }
                    } else {
                        HStack {
                            Text(UIStrings.Notation.suite15Lbl).font(.caption).foregroundStyle(.secondary)
                            Spacer()
                            CompactWheelPicker(value: $local.suiteBigFixed1to5,
                                               range: 0...100,
                                               title: UIStrings.Notation.suite15Lbl)
                        }
                        HStack {
                            Text(UIStrings.Notation.suite20Lbl).font(.caption).foregroundStyle(.secondary)
                            Spacer()
                            CompactWheelPicker(value: $local.suiteBigFixed2to6,
                                               range: 0...100,
                                               title: UIStrings.Notation.suite20Lbl)
                        }
                    }
                }

                // Section basse — Règles des figures
                Section(UIStrings.Notation.bottomRules) {
                    FigureRuleRow(title: "Brelan",       rule: $local.ruleBrelan)
                    FigureRuleRow(title: "Chance",       rule: $local.ruleChance)
                    FigureRuleRow(title: "Full",         rule: $local.ruleFull)
                    FigureRuleRow(title: "Petite suite", rule: $local.rulePetiteSuite)
                    FigureRuleRow(title: "Carré",        rule: $local.ruleCarre)
                    FigureRuleRow(title: "Yams",         rule: $local.ruleYams)

                    Section("Prime Yams supplémentaire") {
                        HStack {
                            Text("Montant")
                            Spacer()
                            TextField("0", value: $local.extraYamsBonusValue, format: .number)
                                .keyboardType(.numberPad)
                                .frame(width: 80)
                                .multilineTextAlignment(.trailing)
                        }
                        Text("Astuce : mettre 0 pour désactiver cette prime dans la notation. L’activation finale se fait à la création d’une partie.")
                            .font(.footnote)
                            .foregroundStyle(.secondary)
                    }
                    .onChange(of: local.extraYamsBonusValue) { oldVal, newVal in
                        local.extraYamsBonusEnabled = newVal > 0
                    }                }

                // Tooltip bas (affichage)
                if let tip = local.tooltipBottom, !tip.isEmpty {
                    Section {
                        Text(tip).font(.footnote).foregroundStyle(.secondary)
                    }
                }
            }

            .navigationTitle("Nouvelle notation")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Annuler") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Créer") {
                        context.insert(local)
                        try? context.save()
                        if let cb = onCreated {
                            cb(local)           // remonte la notation au parent (NewGameView)
                            // on ne dismiss pas ici : NewGameView fermera la sheet
                        } else {
                            dismiss()           // cas d'usage en autonome
                        }
                    }
                    .disabled(local.name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/notations/NotationsListView.swift
================================================================================

//
//  NotationsListView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/08/2025.
//

import SwiftUI
import SwiftData

struct NotationsListView: View {
    @Environment(\.modelContext) private var context
    @Query(sort: \Notation.name) private var notations: [Notation]
    @State private var showingNew = false
    
    var body: some View {
        NavigationStack {
            List {
                ForEach(notations) { n in
                    NavigationLink(value: n.id) {
                        VStack(alignment: .leading, spacing: 6) {
                            Text(n.name).font(.headline)
                            // Lignes d’info
                            Text("Haut : Bonus +\(n.upperBonusValue) si ≥ \(n.upperBonusThreshold)")
                                .font(.caption).foregroundStyle(.secondary)
                            Text("Milieu : " + StatsEngine.middleTooltip(
                                    mode: MiddleRuleMode(rawValue: n.middleModeRaw) ?? .multiplier,
                                    threshold: n.middleBonusSumThreshold,
                                    bonus: n.middleBonusValue))
                                .font(.caption).foregroundStyle(.secondary)
                            Text("Bas : tapote une figure pour son détail")
                                .font(.caption).foregroundStyle(.secondary)
                        }
                    }
                }
                .onDelete { idx in
                    idx.map { notations[$0] }.forEach(context.delete)
                    try? context.save()
                }
            }
            .navigationTitle(UIStrings.Notation.tabTitle)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button { showingNew = true } label: { Label("Ajouter", systemImage: "plus") }
                }
            }
            .sheet(isPresented: $showingNew) {
                NotationEditorView()
            }
            .navigationDestination(for: PersistentIdentifier.self) { id in
                if let n = notations.first(where: { $0.id == id }) {
                    NotationDetailView(notation: n)
                } else {
                    Text("Introuvable")
                }
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/notations/components/CompactWheelPicker.swift
================================================================================

//
//  CompactWheelPicker.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 28/08/2025.
//
import SwiftUI

struct CompactWheelPicker: View {
    @Binding var value: Int
    let range: [Int]
    let title: String
    var display: (Int) -> String = { "\($0)" }
    var width: CGFloat = 110
    var panelWidth: CGFloat = 320
    var panelHeight: CGFloat = 260

    @State private var showing = false

    init(value: Binding<Int>,
         range: ClosedRange<Int>,
         title: String,
         display: @escaping (Int)->String = { "\($0)" },
         width: CGFloat = 110,
         panelWidth: CGFloat = 320,
         panelHeight: CGFloat = 260) {
        self._value = value
        self.range = Array(range)
        self.title = title
        self.display = display
        self.width = width
        self.panelWidth = panelWidth
        self.panelHeight = panelHeight
    }

    var body: some View {
        Button {
            showing = true
        } label: {
            Text(display(value))
                .font(.body.monospacedDigit())
                .frame(minWidth: width)
                .padding(.horizontal, 12).padding(.vertical, 8)
                .background(.ultraThinMaterial)
                .clipShape(RoundedRectangle(cornerRadius: 10))
        }
        .buttonStyle(.plain)
        .fullScreenCover(isPresented: $showing) {
            ZStack {
                // fond cliquable pour fermer (léger voile)
                Color.black.opacity(0.2)
                    .ignoresSafeArea()
                    .onTapGesture { showing = false }

                // petit panneau centré
                VStack(spacing: 12) {
                    Text(title).font(.headline)
                    Picker(title, selection: $value) {
                        ForEach(range, id:\.self) { v in
                            Text(display(v)).tag(v)
                        }
                    }
                    .labelsHidden()
                    .pickerStyle(.wheel)
                    .frame(height: panelHeight - 100)

                    HStack(spacing: 12) {
                        Button("Annuler") { showing = false }
                            .buttonStyle(.bordered)
                        Button("Terminer") { showing = false }
                            .buttonStyle(.borderedProminent)
                    }
                }
                .padding()
                .frame(width: panelWidth, height: panelHeight)
                .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16, style: .continuous))
                .shadow(radius: 12)
            }
            // on garde le fond transparent (pas d’arrière-plan de sheet)
            .presentationBackground(.clear)
        }
    }
}



================================================================================
FILE: YamSheet/Views/players/NewPlayerView.swift
================================================================================

//
//  PlayerEditorView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 30/08/2025.
//
import SwiftUI
import SwiftData

struct NewPlayerView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context

    @State private var draft = PlayerFormView.Draft()

    /// Callback optionnel déclenché une fois le joueur créé et sauvegardé
    var onCreated: ((Player) -> Void)? = nil

    var body: some View {
        PlayerFormView(
            draft: $draft,
            isEditing: false,
            onValidate: { d in
                // Création du joueur avec le nouveau modèle (couleur directe)
                let p = Player(
                    name: d.name.trimmingCharacters(in: .whitespacesAndNewlines),
                    nickname: d.nickname.trimmingCharacters(in: .whitespacesAndNewlines),
                    email: d.email.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : d.email,
                    favoriteEmoji: d.favoriteEmoji.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : d.favoriteEmoji,
                    color: d.preferredColor,
                    avatarImageData: d.avatarImageData,
                    isGuest: d.isGuest
                )
                context.insert(p)
                try? context.save()

                // Notifier l'appelant (NewGameView, etc.)
                onCreated?(p)
                dismiss()
            },
            onCancel: {
                dismiss()
            }
        )
        .navigationTitle("Nouveau joueur")
    }
}



================================================================================
FILE: YamSheet/Views/players/PlayerDetailView.swift
================================================================================

//
//  PlayerDetailView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 03/09/2025.
//


import SwiftUI
import SwiftData

struct PlayerDetailView: View {
    // On reçoit un Player "normal" (pas de @Bindable requis pour afficher)
    let player: Player

    @Environment(\.modelContext) private var context
    @Query private var allGames: [Game]

    // MARK: - Derived metrics
    private var gamesInvolvingPlayer: [Game] {
        allGames.filter { g in g.scorecards.contains { $0.playerID == player.id } }
    }
    private var gamesCount: Int { gamesInvolvingPlayer.count }

    private var completedGames: [Game] {
        gamesInvolvingPlayer.filter { $0.statusOrDefault == .completed }
    }

    private var winsCount: Int {
        var wins = 0
        for g in completedGames {
            // Totaux de la partie via StatsService/StatsEngine (source de vérité)
            let totals = g.scorecards.map { (pid: $0.playerID, total: StatsService.total(for: $0, game: g)) }
            let top = totals.map { $0.total }.max() ?? Int.min
            let winners = totals.filter { $0.total == top }.map { $0.pid }
            if winners.contains(player.id) { wins += 1 }
        }
        return wins
    }

    private var averageScore: Int {
        var scores: [Int] = []
        for g in completedGames {
            if let sc = g.scorecards.first(where: { $0.playerID == player.id }) {
                scores.append(StatsService.total(for: sc, game: g))
            }
        }
        guard !scores.isEmpty else { return 0 }
        let sum = scores.reduce(0, +)
        return Int((Double(sum) / Double(scores.count)).rounded())
    }

    var body: some View {
        List {
            header
            Section("Statistiques") {
                HStack { Label("Parties", systemImage: "gamecontroller"); Spacer(); Text("\(gamesCount)") }
                HStack { Label("Victoires", systemImage: "trophy.fill"); Spacer(); Text("\(winsCount)") }
                HStack { Label("Score moyen", systemImage: "chart.bar"); Spacer(); Text("\(averageScore)") }
            }

            Section("Informations") {
                if let email = player.email, !email.isEmpty {
                    HStack { Label("Email", systemImage: "envelope"); Spacer(); Text(email).textSelection(.enabled) }
                }
                if let emoji = player.favoriteEmoji, !emoji.isEmpty {
                    HStack { Label("Emoji favori", systemImage: "face.smiling"); Spacer(); Text(emoji) }
                }
                HStack {
                    Label("Couleur", systemImage: "paintpalette")
                    Spacer()
                    Circle().fill(player.color).frame(width: 18, height: 18)
                }
            }
        }
        .navigationTitle(player.nickname.isEmpty ? player.name : player.nickname)
        .navigationBarTitleDisplayMode(.inline)
    }

    // MARK: - Header
    private var header: some View {
        Section {
            HStack(spacing: 16) {
                AvatarView(imageData: player.avatarImageData, fallbackColor: player.color)
                VStack(alignment: .leading, spacing: 4) {
                    Text(player.name).font(.title3).bold()
                    if !player.nickname.isEmpty { Text("\(player.nickname)").foregroundStyle(.secondary) }
                }
                Spacer()
            }
            .padding(.vertical, 8)
        }
    }
}

// MARK: - Small Avatar helper (local)
private struct AvatarView: View {
    let imageData: Data?
    let fallbackColor: Color

    var body: some View {
        ZStack {
            Circle().fill(fallbackColor.opacity(0.15))
            if let data = imageData, let ui = UIImage(data: data) {
                Image(uiImage: ui)
                    .resizable()
                    .scaledToFill()
            } else {
                Image(systemName: "person.fill")
                    .imageScale(.large)
                    .font(.title3)
                    .foregroundStyle(.secondary)
            }
        }
        .frame(width: 64, height: 64)
        .clipShape(Circle())
        .overlay { Circle().stroke(.quaternary, lineWidth: 1) }
    }
}



================================================================================
FILE: YamSheet/Views/players/PlayerEditorView.swift
================================================================================

//
//  PlayerEditorView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 30/08/2025.
//

import SwiftUI
import SwiftData

struct PlayerEditorView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context

    @Bindable var player: Player


    @State private var draft: PlayerFormView.Draft = .init()

    var body: some View {
        PlayerFormView(draft: $draft, isEditing: true, onValidate: { d in
            player.name = d.name.trimmingCharacters(in: .whitespacesAndNewlines)
            player.nickname = d.nickname.trimmingCharacters(in: .whitespacesAndNewlines)
            player.email = d.email.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : d.email
            player.favoriteEmoji = d.favoriteEmoji.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? nil : d.favoriteEmoji
            player.color = d.preferredColor
            player.avatarImageData = d.avatarImageData
            player.isGuest = d.isGuest
            try? context.save()
            dismiss()
        }, onCancel: {
            dismiss()
        })
        .navigationTitle("Modifier joueur")
        .onAppear {
            draft = PlayerFormView.Draft(
                name: player.name,
                nickname: player.nickname,
                email: player.email ?? "",
                favoriteEmoji: player.favoriteEmoji ?? "",
                //preferredColor: Color(hex: player.preferredColorHex ?? "") ?? .blue,
                preferredColor: player.color,
                isGuest: player.isGuest,
                avatarImageData: player.avatarImageData
            )
        }
    }
}



================================================================================
FILE: YamSheet/Views/players/PlayersListView.swift
================================================================================

import SwiftUI
import SwiftData

struct PlayersListView: View {
    @Environment(\.modelContext) private var context
    @Query(sort: \Player.name) private var players: [Player]
    @State private var showingNew = false

    var body: some View {
        NavigationStack {
            List {
                ForEach(players) { p in
                    NavigationLink(value: p.id) {
                        VStack(alignment: .leading) {
                            Text(p.name).bold()
                            Text(p.nickname).foregroundStyle(.secondary).font(.caption)
                        }
                    }
                }
                .onDelete { indexSet in
                    indexSet.map { players[$0] }.forEach(context.delete)
                    try? context.save()
                }
            }
            .navigationTitle(UIStrings.Common.players)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button { showingNew = true } label: { Label(UIStrings.Common.toadd, systemImage: "plus") }
                }
            }
            .sheet(isPresented: $showingNew) {
                NewPlayerView()
            }
            .navigationDestination(for: UUID.self) { id in
                if let p = players.first(where: { $0.id == id }) {
                    PlayerDetailView(player: p)
                } else {
                    Text("Introuvable")
                }
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/settings/SettingsView.swift
================================================================================

import SwiftUI
import SwiftData

struct SettingsView: View {
    @Environment(\.modelContext) private var context
    @Query private var settings: [AppSettings]
    @State private var local: AppSettings = AppSettings()
#if DEBUG
    @State private var showDebugSheet = false
#endif

    var body: some View {
        
        
        Form {
            Section(UIStrings.Game.upperSection) {
                Stepper(UIStrings.Notation.upperBonusThresholdLabel+" : \(local.upperBonusThreshold)",
                        value: $local.upperBonusThreshold, in: 0...200)
                Stepper(UIStrings.Notation.upperBonusLabel+" : \(local.upperBonusValue)",
                        value: $local.upperBonusValue, in: 0...200)
            }
            Section(UIStrings.Game.bottomSection) {
                Toggle("Petite suite activée", isOn: $local.enableSmallStraight)
                Stepper("Score petite suite : \(local.smallStraightScore)",
                        value: $local.smallStraightScore, in: 0...100)
                    .disabled(!local.enableSmallStraight)
            }
            Section("App") {
                Toggle("Mode sombre (préférence)", isOn: $local.darkMode)
#if DEBUG
                // Affichage du Debug Settings :
                // 1) NavigationLink (si SettingsView est dans un NavigationStack)
                NavigationLink("Mode Debug") {
                    DebugSettingsView()
                }
                // 2) Fallback : bouton qui ouvre la vue en feuille au cas où il n'y a pas de NavigationStack
                Button {
                    showDebugSheet = true
                } label: {
                    Label("Mode Debug (feuille)", systemImage: "ladybug.fill")
                }
#endif
            }
        }
        .navigationTitle("Réglages")
        .toolbar {
            ToolbarItem(placement: .confirmationAction) {
                Button("Enregistrer") { save() }
            }
        }
        .onAppear {
            let s = settings.first ?? AppSettings()
            if settings.isEmpty { context.insert(s) }
            local = s
        }
        .onDisappear {
            save()
        }
#if DEBUG
        .sheet(isPresented: $showDebugSheet) {
            NavigationStack {
                DebugSettingsView()
            }
        }
#endif
    }

    private func save() {
        if let s = settings.first {
            s.upperBonusThreshold = local.upperBonusThreshold
            s.upperBonusValue = local.upperBonusValue
            s.enableSmallStraight = local.enableSmallStraight
            s.smallStraightScore = local.smallStraightScore
            s.darkMode = local.darkMode
            try? context.save()
        } else {
            context.insert(local)
            try? context.save()
        }
    }
}




================================================================================
FILE: YamSheet/Views/stats/AppStatsView.swift
================================================================================

//
//  AppStatsView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 21/09/2025.
//

import SwiftUI
import Charts
import SwiftData

private struct VictoryEntry: Identifiable {
    let id = UUID()
    let name: String
    let wins: Int
}

private struct AverageEntry: Identifiable {
    let id = UUID()
    let name: String
    let avg: Double
}

struct AppStatsView: View {
    @EnvironmentObject var statsStore: StatsStore
    let stats: AppStats?
    @Environment(\.modelContext) private var modelContext
    @Query private var allGames: [Game]
    @Query(sort: \Player.nickname, order: .forward) private var allPlayers: [Player]
  

    private var colorByName: [String: Color] {
        Dictionary(uniqueKeysWithValues: allPlayers.map { ($0.nickname.isEmpty ? $0.name : $0.nickname, $0.color) })
    }

    private var domainNamesForCharts: [String] {
        // Assure un ordre stable pour la palette custom
        Array(colorByName.keys).sorted()
    }

    private var rangeColorsForCharts: [Color] {
        domainNamesForCharts.compactMap { colorByName[$0] }
    }

    private var fallbackVictories: [VictoryEntry] {
        guard !allGames.isEmpty else { return [] }
        var winsByPlayer: [UUID: Int] = [:]
        for g in allGames where g.statusOrDefault == .completed {
            var bestPID: UUID? = nil
            var bestScore = Int.min
            for sc in g.scorecards {
                var total = 0
                let mirror = Mirror(reflecting: sc)
                if let totals = mirror.children.first(where: { $0.label == "totals" })?.value as? [Int] {
                    total = totals.last ?? 0
                } else if let totalAll = mirror.children.first(where: { $0.label == "totalAll" })?.value as? Int {
                    total = totalAll
                }
                if total > bestScore {
                    bestScore = total
                    bestPID = sc.playerID
                }
            }
            if let pid = bestPID { winsByPlayer[pid, default: 0] += 1 }
        }
        let nameByID = Dictionary(uniqueKeysWithValues: allPlayers.map { ($0.id, $0.nickname) })
        return winsByPlayer.compactMap { (pid, w) in
            guard let name = nameByID[pid] else { return nil }
            return VictoryEntry(name: name, wins: w)
        }.sorted { $0.wins > $1.wins }
    }

    // Best-effort extraction of a scorecard's final total across various model versions
    private func finalTotal(from sc: Scorecard) -> Int {
        let m = Mirror(reflecting: sc)

        // 1) Direct well-known integer fields
        if let v = m.children.first(where: { $0.label == "totalAll" })?.value as? Int { return v }
        if let v = m.children.first(where: { $0.label == "grandTotal" })?.value as? Int { return v }
        if let v = m.children.first(where: { $0.label == "total" })?.value as? Int { return v }
        if let v = m.children.first(where: { $0.label == "overallTotal" })?.value as? Int { return v }

        // 2) Arrays potentially containing totals – take the last or the max
        if let arr = m.children.first(where: { $0.label == "totals" })?.value as? [Int] { return arr.last ?? 0 }
        if let arr = m.children.first(where: { $0.label == "allTotals" })?.value as? [Int] { return arr.last ?? 0 }
        if let arr = m.children.first(where: { $0.label == "sectionTotals" })?.value as? [Int] { return arr.reduce(0, +) }

        // 3) Any Int field whose name contains "total" or "sum" – keep the max
        var best = 0
        for c in m.children {
            guard let label = c.label?.lowercased() else { continue }
            if let v = c.value as? Int, (label.contains("total") || label.contains("sum")) {
                best = max(best, v)
            }
            if let arr = c.value as? [Int], (label.contains("total") || label.contains("sum")) {
                if let last = arr.last { best = max(best, last) }
            }
        }

        // 4) Numeric strings that look like totals (e.g., "123" or "Total: 245") – take the max number found
        if best == 0 {
            var numericMax = 0
            for c in m.children {
                guard let label = c.label?.lowercased() else { continue }
                if label.contains("total"), let s = c.value as? String {
                    let digits = s.filter { $0.isNumber }
                    if let v = Int(digits) { numericMax = max(numericMax, v) }
                }
            }
            best = max(best, numericMax)
        }
        return best
    }

    private var fallbackAverages: [AverageEntry] {
        guard !allGames.isEmpty else { return [] }
        var sums: [UUID: Int] = [:]
        var counts: [UUID: Int] = [:]
        for g in allGames where g.statusOrDefault == .completed {
            for sc in g.scorecards {
                let total = finalTotal(from: sc)
                sums[sc.playerID, default: 0] += total
                counts[sc.playerID, default: 0] += 1
            }
        }
        let nameByID = Dictionary(uniqueKeysWithValues: allPlayers.map { ($0.id, $0.nickname) })
        return sums.compactMap { (pid, sum) in
            guard let c = counts[pid], c > 0, let name = nameByID[pid] else { return nil }
            return AverageEntry(name: name, avg: Double(sum) / Double(c))
        }.sorted { $0.avg > $1.avg }
    }

    // Compute averages directly from the canonical score engine (StatsService/StatsEngine)
    private func averagesFromEngine() -> [AverageEntry] {
        guard !allGames.isEmpty else { return [] }
        var sums: [UUID: Int] = [:]
        var counts: [UUID: Int] = [:]
        for g in allGames where g.statusOrDefault == .completed {
            for sc in g.scorecards {
                let t = StatsService.total(for: sc, game: g)
                sums[sc.playerID, default: 0] += t
                counts[sc.playerID, default: 0] += 1
            }
        }
        let nameByID = Dictionary(uniqueKeysWithValues: allPlayers.map { ($0.id, $0.nickname) })
        return sums.compactMap { (pid, sum) in
            guard let c = counts[pid], c > 0, let name = nameByID[pid] else { return nil }
            return AverageEntry(name: name, avg: Double(sum) / Double(c))
        }
    }

    var body: some View {
        List {
            if let s = stats {
                // Section: Général
                Section("Général") {
                    LabeledContent("Parties (total)", value: "\(s.totalGames)")
                    LabeledContent("Parties terminées", value: "\(s.completedGames)")
                    LabeledContent("Joueurs", value: "\(s.totalPlayers)")
                }

                // Section: Records
                Section("Records") {
                    if let best = s.bestScoreEver {
                        LabeledContent("Meilleur score", value: "\(best.score) — \(best.name)")
                    } else {
                        Text("Pas encore de partie terminée.")
                    }
                    if let mw = s.mostWins {
                        LabeledContent("Plus de victoires", value: "\(mw.wins) — \(mw.name)")
                    }
                }

                // Section: Victoires par joueur (Bar Chart)
                Section("Victoires par joueur") {
                    let victories: [VictoryEntry] = {
                        let fromStore = statsStore.playerStats
                            .map { VictoryEntry(name: $0.name, wins: $0.wins) }
                            .filter { $0.wins > 0 }
                        return fromStore.isEmpty ? fallbackVictories : fromStore
                    }()
                    if !victories.isEmpty {
                        Chart {
                            ForEach(victories) { entry in
                                SectorMark(
                                    angle: .value("Victoires", entry.wins),
                                    innerRadius: .ratio(0.5),
                                    angularInset: 2
                                )
                                .foregroundStyle(by: .value("Joueur", entry.name))
                                .annotation(position: .overlay, alignment: .center) {
                                    Text(entry.name).font(.caption2)
                                }
                            }
                        }
                        .chartForegroundStyleScale(domain: domainNamesForCharts, range: rangeColorsForCharts)
                        .frame(height: 220)
                        
                    } else {
                        Text("Aucune donnée de victoires par joueur.").foregroundStyle(.secondary)
                    }
                }

                // Section: Score moyen par joueur (Bar Chart)
                Section("Score moyen par joueur") {
                    let avgsFromStore: [AverageEntry] = statsStore.playerStats.map { AverageEntry(name: $0.name, avg: $0.avgScore) }

                    // 2) Fallback: si le store est vide **ou** ne retourne que des 0, on calcule via StatsService/StatsEngine
                    let avgs: [AverageEntry] = {
                        if avgsFromStore.isEmpty || avgsFromStore.allSatisfy({ $0.avg == 0 }) {
                            let engine = averagesFromEngine()
                            return engine.isEmpty ? fallbackAverages : engine
                        }
                        return avgsFromStore
                    }()
                    let avgsSorted = avgs.sorted { $0.avg > $1.avg }

                    if !avgsSorted.isEmpty {
                        let maxAvg = avgsSorted.map { $0.avg }.max() ?? 0
                        Chart {
                            ForEach(avgsSorted) { entry in
                                BarMark(
                                    x: .value("Joueur", entry.name),
                                    y: .value("Moyenne", entry.avg)
                                )
                                .foregroundStyle(by: .value("Joueur", entry.name))
                                .annotation(position: .overlay, alignment: .center) {
                                    Text("\(Int(entry.avg.rounded()))")
                                        .font(.caption2)
                                        .bold()
                                }
                            }
                        }
                        .chartForegroundStyleScale(domain: domainNamesForCharts, range: rangeColorsForCharts)
                        .chartYScale(domain: 0...(maxAvg > 0 ? maxAvg * 1.1 : 1))
                        .frame(height: 220)
                    } else {
                        Text("Pas encore assez de parties pour calculer des moyennes.")
                            .foregroundStyle(.secondary)
                    }
                }

                // Section: Répartition des victoires (Pie Chart)
                Section("Répartition des victoires") {
                    let victories: [VictoryEntry] = {
                        let fromStore = statsStore.playerStats
                            .map { VictoryEntry(name: $0.name, wins: $0.wins) }
                            .filter { $0.wins > 0 }
                        return fromStore.isEmpty ? fallbackVictories : fromStore
                    }()
                    if !victories.isEmpty {
                        Chart {
                            ForEach(victories) { entry in
                                SectorMark(
                                    angle: .value("Victoires", entry.wins),
                                    innerRadius: .ratio(0.5),
                                    angularInset: 2
                                )
                                .foregroundStyle(by: .value("Joueur", entry.name))
                                .annotation(position: .overlay, alignment: .center) {
                                    Text(entry.name)
                                        .font(.caption2)
                                }
                            }
                        }
                        .frame(height: 220)
                    } else {
                        Text("Aucune donnée sur la répartition des victoires.").foregroundStyle(.secondary)
                    }
                }

            } else {
                Text("Calcul des statistiques…").foregroundStyle(.secondary)
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/stats/PlayerStatsDetailView.swift
================================================================================

//
//  PlayerStatsDetailView.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 22/09/2025.
//
import SwiftUI
import Charts
import SwiftData

struct PlayerStatsDetailView: View {
    
    let stats: PlayerStats

    @Query private var allPlayers: [Player]

    private var playerColor: Color {
        allPlayers.first(where: { $0.id == stats.playerID })?.color ?? .accentColor
    }
    
    @EnvironmentObject private var statsStore: StatsStore
    @Environment(\.modelContext) private var modelContext
    @Query private var allGames: [Game]

    // Helpers for charts
    private var scoresIndexed: [(index: Int, score: Int)] {
        stats.scoresHistory.enumerated().map { (idx, v) in (idx + 1, v) }
    }
    private var scoreDistribution: [(bucket: String, count: Int)] {
        guard !stats.scoresHistory.isEmpty else { return [] }
        // Buckets of 50 points: 0-49, 50-99, ... up to max
        let maxScore = stats.scoresHistory.max() ?? 0
        let upper = ((maxScore / 50) + 1) * 50
        var bins: [String: Int] = [:]
        for s in stride(from: 0, through: upper, by: 50) {
            let key = String(format: "%d–%d", s, min(s+49, upper))
            bins[key] = 0
        }
        for v in stats.scoresHistory {
            let bucketStart = (v / 50) * 50
            let key = String(format: "%d–%d", bucketStart, min(bucketStart+49, upper))
            bins[key, default: 0] += 1
        }
        // keep natural order
        return bins.keys.sorted { a, b in
            let aStart = Int(a.split(separator: "–").first ?? "0") ?? 0
            let bStart = Int(b.split(separator: "–").first ?? "0") ?? 0
            return aStart < bStart
        }.map { k in (k, bins[k] ?? 0) }
    }
    private var extraYamsCount: Int {
        // Utilise directement les parties via SwiftData (@Query)
        StatsService.yamsPrimesCount(for: stats.playerID, games: allGames)
    }

    var body: some View {
        List {
            // KPIs row
            Section("Résumé") {
                KPIGrid(stats: stats, extraYamsCount: extraYamsCount)
                .listRowInsets(EdgeInsets(top: 8, leading: 0, bottom: 8, trailing: 0))
            }

            if !stats.scoresHistory.isEmpty {
                Section("Évolution des scores") {
                    Chart {
                        ForEach(scoresIndexed, id: \.index) { pt in
                            AreaMark(
                                x: .value("Partie", pt.index),
                                y: .value("Score", pt.score)
                                

                            )
                            .opacity(0.12)
                            .foregroundStyle(playerColor.opacity(0.25))   // ← fill teinté
                            LineMark(
                                x: .value("Partie", pt.index),
                                y: .value("Score", pt.score)
                            )
                            .interpolationMethod(.catmullRom)
                            .lineStyle(StrokeStyle(lineWidth: 2))
                            .foregroundStyle(playerColor)
                            PointMark(
                                x: .value("Partie", pt.index),
                                y: .value("Score", pt.score)
                            )
                            .foregroundStyle(playerColor)
                        }
                    }
                    .frame(height: 220)
                }

                Section("Distribution des scores") {
                    Chart {
                        ForEach(scoreDistribution, id: \.bucket) { bin in
                            BarMark(
                                x: .value("Plage", bin.bucket),
                                y: .value("Occurrences", bin.count)
                            )
                            .foregroundStyle(playerColor)                 // ← barres teintées
                            .annotation(position: .top, alignment: .center) {
                                if bin.count > 0 {
                                    Text("\(bin.count)").font(.caption2)
                                }
                            }
                        }
                    }
                    .chartXAxis {
                        AxisMarks(position: .bottom) { _ in
                            AxisGridLine().foregroundStyle(.clear) // éviter le bruit
                            AxisTick()
                            AxisValueLabel()
                        }
                    }
                    .chartYAxis {
                        AxisMarks(position: .leading) { value in
                            AxisGridLine()
                            AxisValueLabel()
                        }
                    }
                    .frame(height: 220)
                }
            }
        }
        .navigationTitle(stats.name)
    }
}

// MARK: - KPI Grid
private struct KPIGrid: View {
    let stats: PlayerStats
    let extraYamsCount: Int

    var body: some View {
        VStack(spacing: 12) {
            HStack(spacing: 12) {
                KPI(title: "Parties", value: "\(stats.gamesPlayed)")
                KPI(title: "Victoires", value: "\(stats.wins)")
                KPI(title: "% Win", value: "\(Int(stats.winRate * 100))%")
            }
            HStack(spacing: 12) {
                KPI(title: "Moyenne", value: "\(Int(stats.avgScore.rounded()))")
                KPI(title: "Best", value: "\(stats.bestScore)")
                KPI(title: "Worst", value: "\(stats.worstScore)")
            }
            HStack(spacing: 12) {
                KPI(title: "Taux Yams", value: "\(Int(stats.yamsRate * 100))%")
                KPI(title: "Primes Yams", value: "\(extraYamsCount)")
            }
        }
        .padding(.vertical, 4)
    }
}

private struct KPI: View {
    let title: String
    let value: String

    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text(title).font(.caption).foregroundStyle(.secondary)
            Text(value).font(.title3).bold()
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(12)
        .background(
            RoundedRectangle(cornerRadius: 10)
                .fill(.ultraThinMaterial)
        )
    }
}



================================================================================
FILE: YamSheet/Views/stats/PlayerStatsList.swift
================================================================================

//
//  PlayerStatsList.swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 21/09/2025.
//

import SwiftUI

struct PlayerStatsList: View {
    let stats: [PlayerStats]   // <- injecté

    var body: some View {
        List(stats) { s in
            NavigationLink {
                PlayerStatsDetailView(stats: s)   // déjà prêt pour les Charts
            } label: {
                HStack {
                    VStack(alignment: .leading) {
                        Text(s.name).font(.headline)
                        Text("\(s.gamesPlayed) parties • \(s.wins) victoires • \(Int(s.winRate * 100))%")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }
                    Spacer()
                    VStack(alignment: .trailing) {
                        Text("Moy: \(Int(s.avgScore.rounded()))")
                        Text("Best: \(s.bestScore)")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }
                }
            }
        }
    }
}



================================================================================
FILE: YamSheet/Views/tabs/StatisticsTab.swift
================================================================================

//
//  StatisticsTab..swift
//  YamSheet
//
//  Created by Jonathan Sportiche  on 21/09/2025.
//
import SwiftUI
import SwiftData

struct StatisticsTab: View {
    @Query private var players: [Player]
    @Query private var games: [Game]

    @StateObject private var store = StatsStore()
    @State private var selection: Int = 0

    var body: some View {
        NavigationStack {
            VStack {
                Picker("", selection: $selection) {
                    Text("Joueurs").tag(0)
                    Text("Global").tag(1)
                }
                .pickerStyle(.segmented)
                .padding()

                if selection == 0 {
                    PlayerStatsList(stats: store.playerStats)
                } else {
                    AppStatsView(stats: store.appStats)
                }
            }
            .navigationTitle("Statistiques")
            .onAppear { store.refresh(players: players, games: games) }
            .onChange(of: players) { _, _ in store.refresh(players: players, games: games) }
            .onChange(of: games) { _, _ in store.refresh(players: players, games: games) }
        }
    }
}



================================================================================
FILE: YamSheet/YamSheetApp.swift
================================================================================

import SwiftUI
import SwiftData

@main
struct YamSheetApp: App {
    @StateObject private var statsStore: StatsStore

    var sharedModelContainer: ModelContainer = {
        let schema = Schema([AppSettings.self, Player.self, Game.self, Scorecard.self, Notation.self])
        do {
            // ✅ Reuse the legacy/custom on-disk location so existing data is found on device
            let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
            let url = docs.appendingPathComponent("YamSheet.store")
            let config = ModelConfiguration(url: url)

            let container = try ModelContainer(for: schema, configurations: config)

            // Bootstrap default settings once (idempotent)
            let context = ModelContext(container)
            if (try? context.fetch(FetchDescriptor<AppSettings>()))?.isEmpty ?? true {
                context.insert(AppSettings())
                try? context.save()
            }
            return container
        } catch {
            print("SwiftData custom container failed: \(error). Falling back to in-memory container.")
            let memoryConfig = ModelConfiguration(isStoredInMemoryOnly: true)
            let memoryContainer = try! ModelContainer(for: schema, configurations: memoryConfig)
            return memoryContainer
        }
    }()

    init() {
        // Inject the SwiftData context into StatsStore so it can fetch existing data
        _statsStore = StateObject(wrappedValue: StatsStore())
#if DEBUG
if DebugConfig.autoSeedOnLaunch {
    let ctx = ModelContext(sharedModelContainer)
    DevSeed.seedIfNeeded(ctx)
}
#endif
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(statsStore)
        }
        .modelContainer(sharedModelContainer)
    }
}

